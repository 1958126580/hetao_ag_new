# -*- coding: utf-8 -*-
"""
hetao_ag: Smart Agriculture & Livestock Library (Colab All-in-One)
==================================================================

Generates the complete hetao_ag package, runs tests, and executes examples.
"""

import os
import sys
import subprocess
from pathlib import Path

def install_dependencies():
    """Install required dependencies in Colab"""
    print("=[ Installing Dependencies ]" + "="*40)
    packages = [
        "numpy", "pandas", "scipy", "matplotlib", "pyyaml",
        "rasterio", "geopandas", "shapely",  # Space module
        "pulp",  # Opt module
        "opencv-python-headless", "torch", "torchvision" # Livestock module (headless for server)
    ]
    subprocess.check_call([sys.executable, "-m", "pip", "install"] + packages)
    print("Dependencies installed.\n")

def write_file(path, content):
    """Write content to file, creating directories as needed"""
    p = Path(path)
    p.parent.mkdir(parents=True, exist_ok=True)
    with open(p, "w", encoding="utf-8") as f:
        f.write(content)
    print(f"Created: {path}")

# ============================================================================
# File Contents
# ============================================================================

FILES = {
    "hetao_ag/__init__.py": '# -*- coding: utf-8 -*-\n"""\n河套智慧农牧业库 (hetao_ag)\n===========================\n\n一个面向智慧农业和畜牧业的综合Python库，涵盖土壤建模、水循环管理、\n作物生长模拟、畜牧监测、遥感分析和农场优化。\n\n模块:\n    - core: 核心功能（单位系统、配置、日志、工具）\n    - soil: 土壤水分和盐分建模\n    - water: 蒸散发计算和灌溉调度\n    - crop: 作物生长和胁迫响应\n    - livestock: 动物检测和健康监测\n    - space: 遥感植被指数和分类\n    - opt: 农业优化和决策支持\n\n快速开始:\n    >>> import hetao_ag as hag\n    >>> \n    >>> # 计算参考蒸散发\n    >>> weather = hag.water.WeatherData(t_mean=25, t_max=32, t_min=18)\n    >>> et0 = hag.water.eto_penman_monteith(weather)\n    >>> print(f"ET0: {et0:.2f} mm/day")\n    >>>\n    >>> # 土壤水分模拟\n    >>> soil = hag.soil.SoilMoistureModel(field_capacity=0.32)\n    >>> soil.step_day(rain_mm=15, et_mm=5)\n    >>> print(f"含水量: {soil.moisture:.3f}")\n\n作者: Hetao College\n版本: 1.0.0\n许可证: MIT\n"""\n\n__version__ = "1.0.0"\n__author__ = "Hetao College"\n__license__ = "MIT"\n\n# 导入子模块\nfrom . import core\nfrom . import soil\nfrom . import water\nfrom . import crop\nfrom . import livestock\nfrom . import space\nfrom . import opt\n\n# 常用功能快捷导入\nfrom .core import (\n    Unit, Quantity, ConfigManager, get_logger,\n    meters, hectares, celsius, ds_per_m,\n)\n\n__all__ = [\n    "core",\n    "soil", \n    "water",\n    "crop",\n    "livestock",\n    "space",\n    "opt",\n    # 常用\n    "Unit",\n    "Quantity",\n    "ConfigManager",\n    "get_logger",\n    "meters",\n    "hectares",\n    "celsius",\n    "ds_per_m",\n]\n',
    "hetao_ag/core/__init__.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag.core - 核心功能模块\n=============================\n\n提供智慧农牧业库的基础组件：单位系统、配置管理、日志工具和通用函数。\n\n模块:\n    - units: SI单位系统和物理量类\n    - config: 配置管理器\n    - logger: 日志工具\n    - utils: 通用工具函数\n\n作者: Hetao College\n版本: 1.0.0\n"""\n\nfrom .units import (\n    Unit,\n    Quantity,\n    Dimension,\n    DimensionError,\n    meters,\n    kilometers,\n    hectares,\n    celsius,\n    kilopascals,\n    ds_per_m,\n    megajoules_per_m2,\n    mm_per_day,\n)\n\nfrom .config import (\n    ConfigManager,\n    ConfigError,\n    create_default_config,\n)\n\nfrom .logger import (\n    Logger,\n    get_logger,\n    ColoredFormatter,\n)\n\nfrom .utils import (\n    safe_divide,\n    clamp,\n    linear_interpolate,\n    array_interpolate,\n    day_of_year,\n    degrees_to_radians,\n    radians_to_degrees,\n    moving_average,\n    normalize,\n    rmse,\n    mae,\n    r_squared,\n    ensure_path,\n    ensure_directory,\n    validate_model,\n    ValidationResult,\n    Timer,\n)\n\n__version__ = "1.0.0"\n\n__all__ = [\n    # units\n    "Unit",\n    "Quantity",\n    "Dimension",\n    "DimensionError",\n    "meters",\n    "kilometers",\n    "hectares",\n    "celsius",\n    "kilopascals",\n    "ds_per_m",\n    "megajoules_per_m2",\n    "mm_per_day",\n    # config\n    "ConfigManager",\n    "ConfigError",\n    "create_default_config",\n    # logger\n    "Logger",\n    "get_logger",\n    "ColoredFormatter",\n    # utils\n    "safe_divide",\n    "clamp",\n    "linear_interpolate",\n    "array_interpolate",\n    "day_of_year",\n    "degrees_to_radians",\n    "radians_to_degrees",\n    "moving_average",\n    "normalize",\n    "rmse",\n    "mae",\n    "r_squared",\n    "ensure_path",\n    "ensure_directory",\n    "validate_model",\n    "ValidationResult",\n    "Timer",\n]\n',
    "hetao_ag/core/config.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag.core.config - 配置管理模块\n=====================================\n\n提供灵活的配置管理功能，支持YAML/JSON配置文件和环境变量覆盖。\n\n主要功能:\n    - ConfigManager: 配置管理器，支持分层配置和动态更新\n    - 支持YAML和JSON格式的配置文件\n    - 环境变量优先覆盖（便于部署时注入配置）\n    - 配置验证和默认值\n    - 嵌套键访问（如 "database.host"）\n\n设计原则:\n    - 配置与代码分离，提高可复现性\n    - 支持多环境配置（开发、测试、生产）\n    - 敏感信息通过环境变量注入\n\n作者: Hetao College\n版本: 1.0.0\n"""\n\nimport os\nimport json\nfrom pathlib import Path\nfrom typing import Any, Dict, Optional, Union, List\nfrom copy import deepcopy\nimport warnings\n\n# 尝试导入YAML支持\ntry:\n    import yaml\n    YAML_AVAILABLE = True\nexcept ImportError:\n    YAML_AVAILABLE = False\n    warnings.warn("PyYAML未安装，YAML配置文件支持不可用。使用 pip install pyyaml 安装。")\n\n\nclass ConfigError(Exception):\n    """配置错误异常\n    \n    当配置加载、解析或验证失败时抛出。\n    """\n    pass\n\n\nclass ConfigManager:\n    """配置管理器\n    \n    提供分层配置管理，支持从文件加载配置，并允许环境变量覆盖。\n    \n    特性:\n        - 支持YAML和JSON配置文件\n        - 支持嵌套键访问（点分隔符）\n        - 环境变量自动覆盖\n        - 配置验证和默认值\n        - 配置合并和继承\n    \n    环境变量覆盖规则:\n        - 配置键转换为大写\n        - 点分隔符转换为双下划线\n        - 例如: "database.host" -> "DATABASE__HOST"\n    \n    属性:\n        config: 配置字典\n        config_file: 配置文件路径\n        \n    示例:\n        >>> # 从YAML文件加载\n        >>> config = ConfigManager("config.yaml")\n        >>> db_host = config.get("database.host", "localhost")\n        \n        >>> # 环境变量覆盖\n        >>> os.environ["DATABASE__HOST"] = "production-server"\n        >>> db_host = config.get("database.host")  # 返回 "production-server"\n        \n        >>> # 设置和更新配置\n        >>> config.set("api.timeout", 30)\n    """\n    \n    def __init__(\n        self,\n        config_file: Optional[Union[str, Path]] = None,\n        defaults: Optional[Dict[str, Any]] = None,\n        env_prefix: str = "",\n        auto_reload: bool = False\n    ):\n        """初始化配置管理器\n        \n        参数:\n            config_file: 配置文件路径（YAML或JSON）\n            defaults: 默认配置字典\n            env_prefix: 环境变量前缀（用于区分不同应用）\n            auto_reload: 是否自动重新加载配置文件（文件变化时）\n            \n        异常:\n            ConfigError: 配置文件加载失败\n        """\n        self._config: Dict[str, Any] = {}\n        self._defaults: Dict[str, Any] = defaults or {}\n        self._env_prefix = env_prefix.upper() + "__" if env_prefix else ""\n        self._config_file: Optional[Path] = None\n        self._auto_reload = auto_reload\n        self._last_modified: Optional[float] = None\n        \n        # 先应用默认配置\n        if defaults:\n            self._config = deepcopy(defaults)\n        \n        # 加载配置文件\n        if config_file:\n            self.load(config_file)\n    \n    def load(self, config_file: Union[str, Path]) -> \'ConfigManager\':\n        """加载配置文件\n        \n        支持YAML(.yaml, .yml)和JSON(.json)格式。\n        \n        参数:\n            config_file: 配置文件路径\n            \n        返回:\n            self，支持链式调用\n            \n        异常:\n            ConfigError: 文件不存在或格式不支持\n        """\n        path = Path(config_file)\n        \n        if not path.exists():\n            raise ConfigError(f"配置文件不存在: {path}")\n        \n        self._config_file = path\n        self._last_modified = path.stat().st_mtime\n        \n        suffix = path.suffix.lower()\n        \n        try:\n            with open(path, \'r\', encoding=\'utf-8\') as f:\n                if suffix in (\'.yaml\', \'.yml\'):\n                    if not YAML_AVAILABLE:\n                        raise ConfigError("需要安装PyYAML才能加载YAML文件")\n                    file_config = yaml.safe_load(f) or {}\n                elif suffix == \'.json\':\n                    file_config = json.load(f)\n                else:\n                    raise ConfigError(f"不支持的配置文件格式: {suffix}")\n        except (yaml.YAMLError, json.JSONDecodeError) as e:\n            raise ConfigError(f"配置文件解析失败: {e}")\n        \n        # 合并配置（文件配置覆盖默认值）\n        self._config = self._deep_merge(self._config, file_config)\n        \n        return self\n    \n    def _deep_merge(self, base: Dict, override: Dict) -> Dict:\n        """深度合并两个字典\n        \n        参数:\n            base: 基础字典\n            override: 覆盖字典\n            \n        返回:\n            合并后的新字典\n        """\n        result = deepcopy(base)\n        \n        for key, value in override.items():\n            if key in result and isinstance(result[key], dict) and isinstance(value, dict):\n                result[key] = self._deep_merge(result[key], value)\n            else:\n                result[key] = deepcopy(value)\n        \n        return result\n    \n    def get(self, key: str, default: Any = None) -> Any:\n        """获取配置值\n        \n        支持点分隔的嵌套键访问。环境变量优先于配置文件。\n        \n        参数:\n            key: 配置键（支持点分隔，如 "database.host"）\n            default: 默认值（如果配置不存在）\n            \n        返回:\n            配置值\n            \n        示例:\n            >>> config.get("database.host", "localhost")\n            >>> config.get("logging.level", "INFO")\n        """\n        # 检查是否需要重新加载\n        if self._auto_reload:\n            self._check_reload()\n        \n        # 首先检查环境变量\n        env_key = self._to_env_key(key)\n        env_value = os.getenv(env_key)\n        if env_value is not None:\n            return self._parse_env_value(env_value)\n        \n        # 然后从配置字典获取\n        value = self._get_nested(self._config, key)\n        \n        if value is not None:\n            return value\n        \n        # 最后检查默认值字典\n        default_value = self._get_nested(self._defaults, key)\n        if default_value is not None:\n            return default_value\n        \n        return default\n    \n    def _to_env_key(self, key: str) -> str:\n        """将配置键转换为环境变量名\n        \n        参数:\n            key: 配置键\n            \n        返回:\n            环境变量名\n        """\n        # 点分隔符转换为双下划线，全部大写\n        env_key = key.replace(".", "__").upper()\n        return self._env_prefix + env_key\n    \n    def _parse_env_value(self, value: str) -> Any:\n        """解析环境变量值\n        \n        尝试将字符串解析为适当的类型（bool, int, float）。\n        \n        参数:\n            value: 环境变量字符串值\n            \n        返回:\n            解析后的值\n        """\n        # 布尔值\n        if value.lower() in (\'true\', \'yes\', \'1\', \'on\'):\n            return True\n        if value.lower() in (\'false\', \'no\', \'0\', \'off\'):\n            return False\n        \n        # 尝试解析为数字\n        try:\n            if \'.\' in value:\n                return float(value)\n            return int(value)\n        except ValueError:\n            pass\n        \n        # JSON数组或对象\n        if value.startswith((\'[\', \'{\')):\n            try:\n                return json.loads(value)\n            except json.JSONDecodeError:\n                pass\n        \n        return value\n    \n    def _get_nested(self, data: Dict, key: str) -> Any:\n        """获取嵌套字典中的值\n        \n        参数:\n            data: 字典\n            key: 点分隔的键\n            \n        返回:\n            值或None\n        """\n        parts = key.split(".")\n        current = data\n        \n        for part in parts:\n            if isinstance(current, dict) and part in current:\n                current = current[part]\n            else:\n                return None\n        \n        return current\n    \n    def set(self, key: str, value: Any) -> \'ConfigManager\':\n        """设置配置值\n        \n        参数:\n            key: 配置键（支持点分隔）\n            value: 配置值\n            \n        返回:\n            self，支持链式调用\n            \n        示例:\n            >>> config.set("api.timeout", 30).set("api.retries", 3)\n        """\n        parts = key.split(".")\n        current = self._config\n        \n        for part in parts[:-1]:\n            if part not in current:\n                current[part] = {}\n            current = current[part]\n        \n        current[parts[-1]] = value\n        return self\n    \n    def _check_reload(self):\n        """检查并重新加载配置文件（如果已修改）"""\n        if self._config_file and self._config_file.exists():\n            current_mtime = self._config_file.stat().st_mtime\n            if current_mtime != self._last_modified:\n                # 保存当前设置的值\n                runtime_config = deepcopy(self._config)\n                # 重新加载\n                self.load(self._config_file)\n                # 合并运行时设置（运行时设置优先）\n                self._config = self._deep_merge(self._config, runtime_config)\n    \n    def get_section(self, section: str) -> Dict[str, Any]:\n        """获取配置段落\n        \n        参数:\n            section: 段落名称\n            \n        返回:\n            段落配置字典的副本\n            \n        示例:\n            >>> db_config = config.get_section("database")\n            >>> print(db_config)  # {\'host\': \'localhost\', \'port\': 5432}\n        """\n        value = self.get(section, {})\n        if isinstance(value, dict):\n            return deepcopy(value)\n        return {}\n    \n    def has(self, key: str) -> bool:\n        """检查配置键是否存在\n        \n        参数:\n            key: 配置键\n            \n        返回:\n            是否存在\n        """\n        return self.get(key) is not None\n    \n    def all(self) -> Dict[str, Any]:\n        """获取所有配置的副本\n        \n        返回:\n            配置字典的深拷贝\n        """\n        return deepcopy(self._config)\n    \n    def save(self, path: Optional[Union[str, Path]] = None):\n        """保存配置到文件\n        \n        参数:\n            path: 保存路径（默认为原配置文件路径）\n            \n        异常:\n            ConfigError: 无法确定保存路径或写入失败\n        """\n        save_path = Path(path) if path else self._config_file\n        \n        if not save_path:\n            raise ConfigError("未指定保存路径")\n        \n        suffix = save_path.suffix.lower()\n        \n        try:\n            with open(save_path, \'w\', encoding=\'utf-8\') as f:\n                if suffix in (\'.yaml\', \'.yml\'):\n                    if not YAML_AVAILABLE:\n                        raise ConfigError("需要安装PyYAML才能保存YAML文件")\n                    yaml.dump(self._config, f, allow_unicode=True, default_flow_style=False)\n                elif suffix == \'.json\':\n                    json.dump(self._config, f, ensure_ascii=False, indent=2)\n                else:\n                    raise ConfigError(f"不支持的配置文件格式: {suffix}")\n        except IOError as e:\n            raise ConfigError(f"保存配置失败: {e}")\n    \n    def validate(self, required_keys: List[str]) -> bool:\n        """验证必需的配置键是否存在\n        \n        参数:\n            required_keys: 必需的配置键列表\n            \n        返回:\n            是否全部存在\n            \n        异常:\n            ConfigError: 缺少必需的配置\n        """\n        missing = [key for key in required_keys if not self.has(key)]\n        \n        if missing:\n            raise ConfigError(f"缺少必需的配置: {\', \'.join(missing)}")\n        \n        return True\n    \n    def __getitem__(self, key: str) -> Any:\n        """字典风格访问"""\n        value = self.get(key)\n        if value is None:\n            raise KeyError(key)\n        return value\n    \n    def __setitem__(self, key: str, value: Any):\n        """字典风格设置"""\n        self.set(key, value)\n    \n    def __contains__(self, key: str) -> bool:\n        """支持 \'in\' 操作符"""\n        return self.has(key)\n    \n    def __repr__(self) -> str:\n        """字符串表示"""\n        return f"ConfigManager(file={self._config_file}, keys={len(self._config)})"\n\n\ndef create_default_config() -> Dict[str, Any]:\n    """创建智慧农牧业系统的默认配置\n    \n    返回:\n        默认配置字典\n    """\n    return {\n        # 系统基础配置\n        "system": {\n            "name": "hetao_ag",\n            "version": "1.0.0",\n            "language": "zh_CN",\n            "timezone": "Asia/Shanghai"\n        },\n        \n        # 日志配置\n        "logging": {\n            "level": "INFO",\n            "format": "%(asctime)s - %(name)s - %(levelname)s - %(message)s",\n            "file": "logs/hetao_ag.log",\n            "max_size_mb": 10,\n            "backup_count": 5\n        },\n        \n        # 土壤模块配置\n        "soil": {\n            "default_depth_m": 0.3,\n            "field_capacity": 0.35,\n            "wilting_point": 0.12\n        },\n        \n        # 水循环模块配置\n        "water": {\n            "et_method": "penman_monteith",\n            "reference_crop_height_m": 0.12,\n            "default_albedo": 0.23\n        },\n        \n        # 作物模块配置\n        "crop": {\n            "default_growing_season_days": 120,\n            "thermal_time_base_celsius": 10.0\n        },\n        \n        # 畜牧模块配置\n        "livestock": {\n            "detection_confidence": 0.5,\n            "model_variant": "yolov5s",\n            "use_gpu": True\n        },\n        \n        # 遥感模块配置\n        "space": {\n            "default_savi_l": 0.5,\n            "cloud_mask_threshold": 0.3\n        },\n        \n        # 优化模块配置\n        "optimization": {\n            "solver": "CBC",\n            "max_iterations": 1000,\n            "tolerance": 1e-6\n        }\n    }\n\n\n# ============================================================================\n# 使用示例\n# ============================================================================\n\nif __name__ == "__main__":\n    import tempfile\n    \n    print("=" * 60)\n    print("河套智慧农牧业库 - 配置管理演示")\n    print("=" * 60)\n    \n    # 演示1: 使用默认配置\n    print("\\n【默认配置】")\n    defaults = create_default_config()\n    config = ConfigManager(defaults=defaults)\n    print(f"  系统名称: {config.get(\'system.name\')}")\n    print(f"  日志级别: {config.get(\'logging.level\')}")\n    \n    # 演示2: 设置和获取配置\n    print("\\n【动态设置配置】")\n    config.set("database.host", "localhost")\n    config.set("database.port", 5432)\n    print(f"  数据库主机: {config.get(\'database.host\')}")\n    print(f"  数据库端口: {config.get(\'database.port\')}")\n    \n    # 演示3: 环境变量覆盖\n    print("\\n【环境变量覆盖】")\n    os.environ["DATABASE__HOST"] = "production-server"\n    print(f"  数据库主机(环境变量覆盖): {config.get(\'database.host\')}")\n    del os.environ["DATABASE__HOST"]  # 清理\n    \n    # 演示4: 保存和加载YAML配置\n    if YAML_AVAILABLE:\n        print("\\n【YAML配置文件】")\n        with tempfile.NamedTemporaryFile(mode=\'w\', suffix=\'.yaml\', delete=False, encoding=\'utf-8\') as f:\n            yaml.dump({\n                \'farm\': {\n                    \'name\': \'河套示范农场\',\n                    \'area_hectares\': 500\n                }\n            }, f, allow_unicode=True)\n            temp_path = f.name\n        \n        file_config = ConfigManager(temp_path)\n        print(f"  农场名称: {file_config.get(\'farm.name\')}")\n        print(f"  农场面积: {file_config.get(\'farm.area_hectares\')} 公顷")\n        \n        os.unlink(temp_path)  # 清理临时文件\n    \n    # 演示5: 获取配置段落\n    print("\\n【获取配置段落】")\n    soil_config = config.get_section("soil")\n    print(f"  土壤配置: {soil_config}")\n    \n    print("\\n" + "=" * 60)\n    print("配置管理演示完成！")\n    print("=" * 60)\n',
    "hetao_ag/core/logger.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag.core.logger - 日志工具模块\n\n提供标准化的日志功能，支持控制台和文件输出。\n\n作者: Hetao College\n版本: 1.0.0\n"""\n\nimport logging\nimport sys\nfrom pathlib import Path\nfrom typing import Optional, Union\nfrom datetime import datetime\n\ntry:\n    from logging.handlers import RotatingFileHandler\n    HANDLERS_AVAILABLE = True\nexcept ImportError:\n    HANDLERS_AVAILABLE = False\n\n\nclass ColoredFormatter(logging.Formatter):\n    """彩色日志格式化器"""\n    \n    COLORS = {\n        \'DEBUG\': \'\\033[90m\',\n        \'INFO\': \'\\033[92m\',\n        \'WARNING\': \'\\033[93m\',\n        \'ERROR\': \'\\033[91m\',\n        \'CRITICAL\': \'\\033[41m\',\n    }\n    RESET = \'\\033[0m\'\n    \n    def format(self, record: logging.LogRecord) -> str:\n        color = self.COLORS.get(record.levelname, \'\')\n        message = super().format(record)\n        if sys.stdout.isatty() and color:\n            return f"{color}{message}{self.RESET}"\n        return message\n\n\nclass Logger:\n    """智慧农牧业日志记录器\n    \n    示例:\n        >>> logger = Logger("hetao_ag.soil")\n        >>> logger.info("开始土壤分析...")\n    """\n    \n    DEFAULT_FORMAT = "%(asctime)s | %(levelname)-8s | %(name)s | %(message)s"\n    DEFAULT_DATE_FORMAT = "%Y-%m-%d %H:%M:%S"\n    _loggers: dict = {}\n    \n    def __init__(\n        self,\n        name: str = "hetao_ag",\n        level: Union[str, int] = logging.INFO,\n        log_file: Optional[Union[str, Path]] = None,\n        console_output: bool = True,\n        colored: bool = True\n    ):\n        self.name = name\n        \n        if name in Logger._loggers:\n            self._logger = Logger._loggers[name]\n        else:\n            self._logger = logging.getLogger(name)\n            Logger._loggers[name] = self._logger\n        \n        if isinstance(level, str):\n            level = getattr(logging, level.upper(), logging.INFO)\n        self._logger.setLevel(level)\n        self._logger.handlers.clear()\n        \n        if console_output:\n            handler = logging.StreamHandler(sys.stdout)\n            handler.setLevel(level)\n            if colored:\n                formatter = ColoredFormatter(self.DEFAULT_FORMAT, datefmt=self.DEFAULT_DATE_FORMAT)\n            else:\n                formatter = logging.Formatter(self.DEFAULT_FORMAT, datefmt=self.DEFAULT_DATE_FORMAT)\n            handler.setFormatter(formatter)\n            self._logger.addHandler(handler)\n        \n        if log_file:\n            self.add_file_handler(log_file)\n    \n    def add_file_handler(self, log_file: Union[str, Path], max_size_mb: float = 10.0, backup_count: int = 5):\n        log_path = Path(log_file)\n        log_path.parent.mkdir(parents=True, exist_ok=True)\n        \n        if HANDLERS_AVAILABLE:\n            handler = RotatingFileHandler(log_path, maxBytes=int(max_size_mb * 1024 * 1024), backupCount=backup_count, encoding=\'utf-8\')\n        else:\n            handler = logging.FileHandler(log_path, encoding=\'utf-8\')\n        \n        handler.setLevel(self._logger.level)\n        handler.setFormatter(logging.Formatter(self.DEFAULT_FORMAT, datefmt=self.DEFAULT_DATE_FORMAT))\n        self._logger.addHandler(handler)\n    \n    def set_level(self, level: Union[str, int]):\n        if isinstance(level, str):\n            level = getattr(logging, level.upper(), logging.INFO)\n        self._logger.setLevel(level)\n        for handler in self._logger.handlers:\n            handler.setLevel(level)\n    \n    def debug(self, msg: str, **kwargs):\n        extra = " | ".join(f"{k}={v}" for k, v in kwargs.items()) if kwargs else ""\n        self._logger.debug(msg + (" | " + extra if extra else ""))\n    \n    def info(self, msg: str, **kwargs):\n        extra = " | ".join(f"{k}={v}" for k, v in kwargs.items()) if kwargs else ""\n        self._logger.info(msg + (" | " + extra if extra else ""))\n    \n    def warning(self, msg: str, **kwargs):\n        extra = " | ".join(f"{k}={v}" for k, v in kwargs.items()) if kwargs else ""\n        self._logger.warning(msg + (" | " + extra if extra else ""))\n    \n    def error(self, msg: str, exc_info: bool = False, **kwargs):\n        extra = " | ".join(f"{k}={v}" for k, v in kwargs.items()) if kwargs else ""\n        self._logger.error(msg + (" | " + extra if extra else ""), exc_info=exc_info)\n    \n    def critical(self, msg: str, exc_info: bool = True, **kwargs):\n        extra = " | ".join(f"{k}={v}" for k, v in kwargs.items()) if kwargs else ""\n        self._logger.critical(msg + (" | " + extra if extra else ""), exc_info=exc_info)\n    \n    def exception(self, msg: str, **kwargs):\n        extra = " | ".join(f"{k}={v}" for k, v in kwargs.items()) if kwargs else ""\n        self._logger.exception(msg + (" | " + extra if extra else ""))\n    \n    def log_experiment_start(self, experiment_name: str, parameters: Optional[dict] = None, random_seed: Optional[int] = None):\n        """记录实验开始"""\n        self.info("=" * 50)\n        self.info(f"实验开始: {experiment_name}")\n        self.info(f"时间: {datetime.now().isoformat()}")\n        if random_seed is not None:\n            self.info(f"随机种子: {random_seed}")\n        if parameters:\n            for key, value in parameters.items():\n                self.info(f"  {key}: {value}")\n        self.info("=" * 50)\n    \n    def log_experiment_end(self, success: bool = True, results: Optional[dict] = None):\n        """记录实验结束"""\n        self.info("=" * 50)\n        self.info(f"实验结束 - 状态: {\'成功\' if success else \'失败\'}")\n        if results:\n            for key, value in results.items():\n                self.info(f"  {key}: {value}")\n        self.info("=" * 50)\n\n\ndef get_logger(name: str = "hetao_ag", **kwargs) -> Logger:\n    """获取日志记录器"""\n    return Logger(name, **kwargs)\n\n\nif __name__ == "__main__":\n    logger = get_logger("hetao_ag.demo", level="DEBUG")\n    logger.debug("调试信息")\n    logger.info("系统初始化完成")\n    logger.warning("内存使用率高", memory_percent=85)\n',
    "hetao_ag/core/units.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag.core.units - 单位系统模块\n=====================================\n\n提供国际标准(SI)单位系统，支持自动单位转换和物理量运算。\n\n主要功能:\n    - Unit: 单位枚举类，定义常用单位及其SI转换因子\n    - Quantity: 物理量类，支持带单位的数值运算\n    - DimensionError: 量纲不匹配异常\n\n设计原则:\n    - 内部统一使用SI单位，避免单位混淆导致的严重错误\n    - 参考NASA火星气候轨道器事故教训（公制与英制混淆）\n    - 符合国际计量标准\n\n作者: Hetao College\n版本: 1.0.0\n"""\n\nfrom enum import Enum\nfrom typing import Union, Optional\nfrom dataclasses import dataclass\nimport math\n\n\nclass DimensionError(Exception):\n    """量纲不匹配异常\n    \n    当尝试对不同量纲的物理量进行不兼容运算时抛出。\n    \n    示例:\n        >>> length = Quantity(1.0, Unit.METER)\n        >>> mass = Quantity(1.0, Unit.KILOGRAM)\n        >>> length + mass  # 引发 DimensionError\n    """\n    pass\n\n\nclass Dimension(Enum):\n    """物理量纲枚举\n    \n    定义基本物理量纲，用于确保运算的量纲一致性。\n    \n    属性:\n        LENGTH: 长度量纲\n        AREA: 面积量纲\n        VOLUME: 体积量纲\n        MASS: 质量量纲\n        TIME: 时间量纲\n        TEMPERATURE: 温度量纲\n        PRESSURE: 压强量纲\n        VELOCITY: 速度量纲\n        CONDUCTIVITY: 电导率量纲\n        DIMENSIONLESS: 无量纲\n    """\n    LENGTH = "length"\n    AREA = "area"\n    VOLUME = "volume"\n    MASS = "mass"\n    TIME = "time"\n    TEMPERATURE = "temperature"\n    PRESSURE = "pressure"\n    VELOCITY = "velocity"\n    CONDUCTIVITY = "conductivity"\n    ENERGY = "energy"\n    POWER = "power"\n    DIMENSIONLESS = "dimensionless"\n\n\nclass Unit(Enum):\n    """单位枚举类\n    \n    定义常用物理单位及其到SI基本单位的转换因子。\n    每个单位包含: (符号, SI转换因子, 量纲)\n    \n    长度单位:\n        METER, KILOMETER, CENTIMETER, MILLIMETER\n        \n    面积单位:\n        SQUARE_METER, HECTARE, SQUARE_KILOMETER\n        \n    体积单位:\n        CUBIC_METER, LITER, MILLILITER\n        \n    质量单位:\n        KILOGRAM, GRAM, TON\n        \n    时间单位:\n        SECOND, MINUTE, HOUR, DAY\n        \n    温度单位:\n        KELVIN, CELSIUS (注意: 摄氏度需要偏移转换)\n        \n    压强单位:\n        PASCAL, KILOPASCAL, BAR\n        \n    速度单位:\n        METER_PER_SECOND, KILOMETER_PER_HOUR\n        \n    电导率单位:\n        SIEMENS_PER_METER, DECISIEMENS_PER_METER\n        \n    能量和功率单位:\n        JOULE, MEGAJOULE, WATT, KILOWATT\n    \n    示例:\n        >>> Unit.METER.symbol\n        \'m\'\n        >>> Unit.KILOMETER.to_si_factor\n        1000.0\n    """\n    \n    # 长度单位 (基本单位: 米)\n    METER = ("m", 1.0, Dimension.LENGTH)\n    KILOMETER = ("km", 1000.0, Dimension.LENGTH)\n    CENTIMETER = ("cm", 0.01, Dimension.LENGTH)\n    MILLIMETER = ("mm", 0.001, Dimension.LENGTH)\n    \n    # 面积单位 (基本单位: 平方米)\n    SQUARE_METER = ("m²", 1.0, Dimension.AREA)\n    HECTARE = ("ha", 10000.0, Dimension.AREA)\n    SQUARE_KILOMETER = ("km²", 1000000.0, Dimension.AREA)\n    \n    # 体积单位 (基本单位: 立方米)\n    CUBIC_METER = ("m³", 1.0, Dimension.VOLUME)\n    LITER = ("L", 0.001, Dimension.VOLUME)\n    MILLILITER = ("mL", 0.000001, Dimension.VOLUME)\n    \n    # 质量单位 (基本单位: 千克)\n    KILOGRAM = ("kg", 1.0, Dimension.MASS)\n    GRAM = ("g", 0.001, Dimension.MASS)\n    TON = ("t", 1000.0, Dimension.MASS)\n    \n    # 时间单位 (基本单位: 秒)\n    SECOND = ("s", 1.0, Dimension.TIME)\n    MINUTE = ("min", 60.0, Dimension.TIME)\n    HOUR = ("h", 3600.0, Dimension.TIME)\n    DAY = ("d", 86400.0, Dimension.TIME)\n    \n    # 温度单位 (基本单位: 开尔文, 注意摄氏度需要偏移)\n    KELVIN = ("K", 1.0, Dimension.TEMPERATURE)\n    CELSIUS = ("°C", 1.0, Dimension.TEMPERATURE)  # 需要特殊处理偏移\n    \n    # 压强单位 (基本单位: 帕斯卡)\n    PASCAL = ("Pa", 1.0, Dimension.PRESSURE)\n    KILOPASCAL = ("kPa", 1000.0, Dimension.PRESSURE)\n    BAR = ("bar", 100000.0, Dimension.PRESSURE)\n    \n    # 速度单位 (基本单位: 米/秒)\n    METER_PER_SECOND = ("m/s", 1.0, Dimension.VELOCITY)\n    KILOMETER_PER_HOUR = ("km/h", 1.0/3.6, Dimension.VELOCITY)\n    \n    # 电导率单位 (基本单位: S/m, 土壤盐分常用dS/m)\n    SIEMENS_PER_METER = ("S/m", 1.0, Dimension.CONDUCTIVITY)\n    DECISIEMENS_PER_METER = ("dS/m", 0.1, Dimension.CONDUCTIVITY)\n    \n    # 能量单位 (基本单位: 焦耳)\n    JOULE = ("J", 1.0, Dimension.ENERGY)\n    MEGAJOULE = ("MJ", 1000000.0, Dimension.ENERGY)\n    KILOJOULE = ("kJ", 1000.0, Dimension.ENERGY)\n    \n    # 功率单位 (基本单位: 瓦特)\n    WATT = ("W", 1.0, Dimension.POWER)\n    KILOWATT = ("kW", 1000.0, Dimension.POWER)\n    \n    # 无量纲\n    PERCENT = ("%", 0.01, Dimension.DIMENSIONLESS)\n    FRACTION = ("", 1.0, Dimension.DIMENSIONLESS)\n    \n    def __init__(self, symbol: str, to_si: float, dimension: Dimension):\n        """初始化单位\n        \n        参数:\n            symbol: 单位符号\n            to_si: 到SI基本单位的转换因子\n            dimension: 物理量纲\n        """\n        self._symbol = symbol\n        self._to_si = to_si\n        self._dimension = dimension\n    \n    @property\n    def symbol(self) -> str:\n        """获取单位符号"""\n        return self._symbol\n    \n    @property\n    def to_si_factor(self) -> float:\n        """获取到SI单位的转换因子"""\n        return self._to_si\n    \n    @property\n    def dimension(self) -> Dimension:\n        """获取物理量纲"""\n        return self._dimension\n\n\n@dataclass\nclass Quantity:\n    """物理量类\n    \n    表示带有单位的数值，支持自动单位转换和算术运算。\n    所有运算自动确保量纲一致性。\n    \n    属性:\n        value: 数值\n        unit: 单位\n        \n    方法:\n        to(unit): 转换到指定单位\n        to_si(): 转换到SI基本单位\n        \n    运算符支持:\n        +, -, *, /, ==, <, >, <=, >=\n        \n    示例:\n        >>> length1 = Quantity(100, Unit.CENTIMETER)\n        >>> length2 = Quantity(2, Unit.METER)\n        >>> total = length1 + length2\n        >>> print(total)  # 3.0 m (以第一个操作数的单位表示)\n        \n        >>> # 单位转换\n        >>> distance = Quantity(5, Unit.KILOMETER)\n        >>> print(distance.to(Unit.METER))  # 5000.0 m\n    """\n    \n    value: float\n    unit: Unit\n    \n    def __post_init__(self):\n        """验证初始化参数"""\n        if not isinstance(self.unit, Unit):\n            raise TypeError(f"unit必须是Unit枚举类型，得到: {type(self.unit)}")\n        self.value = float(self.value)\n    \n    def to_si(self) -> \'Quantity\':\n        """转换到SI基本单位\n        \n        返回:\n            新的Quantity对象，使用SI基本单位\n            \n        示例:\n            >>> q = Quantity(5, Unit.KILOMETER)\n            >>> q.to_si()\n            Quantity(value=5000.0, unit=<Unit.METER>)\n        """\n        # 找到同量纲的SI基本单位\n        si_units = {\n            Dimension.LENGTH: Unit.METER,\n            Dimension.AREA: Unit.SQUARE_METER,\n            Dimension.VOLUME: Unit.CUBIC_METER,\n            Dimension.MASS: Unit.KILOGRAM,\n            Dimension.TIME: Unit.SECOND,\n            Dimension.TEMPERATURE: Unit.KELVIN,\n            Dimension.PRESSURE: Unit.PASCAL,\n            Dimension.VELOCITY: Unit.METER_PER_SECOND,\n            Dimension.CONDUCTIVITY: Unit.SIEMENS_PER_METER,\n            Dimension.ENERGY: Unit.JOULE,\n            Dimension.POWER: Unit.WATT,\n            Dimension.DIMENSIONLESS: Unit.FRACTION,\n        }\n        target_unit = si_units.get(self.unit.dimension, self.unit)\n        return self.to(target_unit)\n    \n    def to(self, target_unit: Unit) -> \'Quantity\':\n        """转换到指定单位\n        \n        参数:\n            target_unit: 目标单位\n            \n        返回:\n            新的Quantity对象\n            \n        异常:\n            DimensionError: 量纲不匹配\n            \n        示例:\n            >>> q = Quantity(1, Unit.KILOMETER)\n            >>> q.to(Unit.METER)\n            Quantity(value=1000.0, unit=<Unit.METER>)\n        """\n        if self.unit.dimension != target_unit.dimension:\n            raise DimensionError(\n                f"无法将{self.unit.dimension.value}转换为{target_unit.dimension.value}"\n            )\n        \n        # 温度需要特殊处理（摄氏度与开尔文之间有偏移）\n        if self.unit.dimension == Dimension.TEMPERATURE:\n            return self._convert_temperature(target_unit)\n        \n        # 标准转换: 当前值 -> SI值 -> 目标值\n        si_value = self.value * self.unit.to_si_factor\n        new_value = si_value / target_unit.to_si_factor\n        return Quantity(new_value, target_unit)\n    \n    def _convert_temperature(self, target_unit: Unit) -> \'Quantity\':\n        """温度转换（处理摄氏度偏移）\n        \n        参数:\n            target_unit: 目标温度单位\n            \n        返回:\n            转换后的温度Quantity\n        """\n        # 先转换到开尔文\n        if self.unit == Unit.CELSIUS:\n            kelvin_value = self.value + 273.15\n        else:\n            kelvin_value = self.value\n        \n        # 再转换到目标单位\n        if target_unit == Unit.CELSIUS:\n            new_value = kelvin_value - 273.15\n        else:\n            new_value = kelvin_value\n        \n        return Quantity(new_value, target_unit)\n    \n    def __add__(self, other: \'Quantity\') -> \'Quantity\':\n        """加法运算\n        \n        结果使用第一个操作数的单位。\n        \n        参数:\n            other: 另一个Quantity\n            \n        返回:\n            相加结果\n            \n        异常:\n            TypeError: other不是Quantity\n            DimensionError: 量纲不匹配\n        """\n        if not isinstance(other, Quantity):\n            raise TypeError("只能与Quantity相加")\n        if self.unit.dimension != other.unit.dimension:\n            raise DimensionError(\n                f"无法相加: {self.unit.dimension.value} 与 {other.unit.dimension.value}"\n            )\n        \n        # 将other转换到self的单位\n        other_converted = other.to(self.unit)\n        return Quantity(self.value + other_converted.value, self.unit)\n    \n    def __sub__(self, other: \'Quantity\') -> \'Quantity\':\n        """减法运算"""\n        if not isinstance(other, Quantity):\n            raise TypeError("只能与Quantity相减")\n        if self.unit.dimension != other.unit.dimension:\n            raise DimensionError(\n                f"无法相减: {self.unit.dimension.value} 与 {other.unit.dimension.value}"\n            )\n        \n        other_converted = other.to(self.unit)\n        return Quantity(self.value - other_converted.value, self.unit)\n    \n    def __mul__(self, other: Union[\'Quantity\', float, int]) -> \'Quantity\':\n        """乘法运算\n        \n        支持与标量或其他Quantity相乘。\n        注意: 两个Quantity相乘会产生新的量纲。\n        \n        参数:\n            other: 标量或Quantity\n            \n        返回:\n            乘积结果\n        """\n        if isinstance(other, (int, float)):\n            return Quantity(self.value * other, self.unit)\n        elif isinstance(other, Quantity):\n            # 两个Quantity相乘（简化处理，返回SI值的乘积）\n            si_product = (self.value * self.unit.to_si_factor * \n                         other.value * other.unit.to_si_factor)\n            return Quantity(si_product, Unit.FRACTION)\n        else:\n            raise TypeError(f"不支持与{type(other)}相乘")\n    \n    def __rmul__(self, other: Union[float, int]) -> \'Quantity\':\n        """右乘运算"""\n        return self.__mul__(other)\n    \n    def __truediv__(self, other: Union[\'Quantity\', float, int]) -> \'Quantity\':\n        """除法运算"""\n        if isinstance(other, (int, float)):\n            if other == 0:\n                raise ZeroDivisionError("除数不能为零")\n            return Quantity(self.value / other, self.unit)\n        elif isinstance(other, Quantity):\n            if other.value == 0:\n                raise ZeroDivisionError("除数不能为零")\n            # 同量纲相除得到无量纲数\n            if self.unit.dimension == other.unit.dimension:\n                other_converted = other.to(self.unit)\n                return Quantity(self.value / other_converted.value, Unit.FRACTION)\n            else:\n                # 不同量纲相除\n                si_quotient = (self.value * self.unit.to_si_factor / \n                              (other.value * other.unit.to_si_factor))\n                return Quantity(si_quotient, Unit.FRACTION)\n        else:\n            raise TypeError(f"不支持与{type(other)}相除")\n    \n    def __eq__(self, other: \'Quantity\') -> bool:\n        """相等比较"""\n        if not isinstance(other, Quantity):\n            return False\n        if self.unit.dimension != other.unit.dimension:\n            return False\n        other_converted = other.to(self.unit)\n        return math.isclose(self.value, other_converted.value, rel_tol=1e-9)\n    \n    def __lt__(self, other: \'Quantity\') -> bool:\n        """小于比较"""\n        if not isinstance(other, Quantity):\n            raise TypeError("只能与Quantity比较")\n        if self.unit.dimension != other.unit.dimension:\n            raise DimensionError("无法比较不同量纲的物理量")\n        other_converted = other.to(self.unit)\n        return self.value < other_converted.value\n    \n    def __le__(self, other: \'Quantity\') -> bool:\n        """小于等于比较"""\n        return self == other or self < other\n    \n    def __gt__(self, other: \'Quantity\') -> bool:\n        """大于比较"""\n        return not self <= other\n    \n    def __ge__(self, other: \'Quantity\') -> bool:\n        """大于等于比较"""\n        return not self < other\n    \n    def __repr__(self) -> str:\n        """字符串表示"""\n        return f"Quantity({self.value}, {self.unit.name})"\n    \n    def __str__(self) -> str:\n        """人类可读的字符串"""\n        return f"{self.value:.4g} {self.unit.symbol}"\n    \n    def __float__(self) -> float:\n        """转换为浮点数（返回SI值）"""\n        return self.value * self.unit.to_si_factor\n    \n    def __neg__(self) -> \'Quantity\':\n        """取负"""\n        return Quantity(-self.value, self.unit)\n    \n    def __abs__(self) -> \'Quantity\':\n        """取绝对值"""\n        return Quantity(abs(self.value), self.unit)\n\n\n# ============================================================================\n# 便捷函数和常量\n# ============================================================================\n\ndef meters(value: float) -> Quantity:\n    """创建米为单位的长度\n    \n    示例:\n        >>> distance = meters(100)\n        >>> print(distance)\n        100.0 m\n    """\n    return Quantity(value, Unit.METER)\n\n\ndef kilometers(value: float) -> Quantity:\n    """创建千米为单位的长度"""\n    return Quantity(value, Unit.KILOMETER)\n\n\ndef hectares(value: float) -> Quantity:\n    """创建公顷为单位的面积"""\n    return Quantity(value, Unit.HECTARE)\n\n\ndef celsius(value: float) -> Quantity:\n    """创建摄氏度为单位的温度"""\n    return Quantity(value, Unit.CELSIUS)\n\n\ndef kilopascals(value: float) -> Quantity:\n    """创建千帕为单位的压强"""\n    return Quantity(value, Unit.KILOPASCAL)\n\n\ndef ds_per_m(value: float) -> Quantity:\n    """创建dS/m为单位的电导率（土壤盐分常用单位）\n    \n    示例:\n        >>> soil_ec = ds_per_m(4.5)  # 土壤盐分4.5 dS/m\n    """\n    return Quantity(value, Unit.DECISIEMENS_PER_METER)\n\n\ndef megajoules_per_m2(value: float) -> Quantity:\n    """创建MJ/m²为单位的能量（太阳辐射常用单位）"""\n    return Quantity(value, Unit.MEGAJOULE)\n\n\ndef mm_per_day(value: float) -> Quantity:\n    """创建mm/day为单位的蒸散发速率\n    \n    注: 1 mm/day 水深变化相当于 1 L/m²/day\n    """\n    return Quantity(value, Unit.MILLIMETER)\n\n\n# ============================================================================\n# 使用示例\n# ============================================================================\n\nif __name__ == "__main__":\n    print("=" * 60)\n    print("河套智慧农牧业库 - 单位系统演示")\n    print("=" * 60)\n    \n    # 演示1: 长度单位转换\n    print("\\n【长度单位转换】")\n    distance_km = Quantity(5.5, Unit.KILOMETER)\n    distance_m = distance_km.to(Unit.METER)\n    print(f"  {distance_km} = {distance_m}")\n    \n    # 演示2: 单位加法（自动转换）\n    print("\\n【单位加法】")\n    length1 = Quantity(100, Unit.CENTIMETER)\n    length2 = Quantity(2, Unit.METER)\n    total = length1 + length2\n    print(f"  {length1} + {length2} = {total}")\n    \n    # 演示3: 面积单位\n    print("\\n【面积单位】")\n    field_area = Quantity(150, Unit.HECTARE)\n    field_sqm = field_area.to(Unit.SQUARE_METER)\n    print(f"  农田面积: {field_area} = {field_sqm}")\n    \n    # 演示4: 温度转换\n    print("\\n【温度转换】")\n    temp_c = Quantity(25, Unit.CELSIUS)\n    temp_k = temp_c.to(Unit.KELVIN)\n    print(f"  {temp_c} = {temp_k}")\n    \n    # 演示5: 土壤盐分（电导率）\n    print("\\n【土壤盐分】")\n    soil_ec = ds_per_m(6.5)\n    print(f"  土壤电导率: {soil_ec}")\n    \n    # 演示6: 便捷函数\n    print("\\n【便捷函数使用】")\n    farm_size = hectares(500)\n    daily_temp = celsius(28.5)\n    print(f"  农场规模: {farm_size}")\n    print(f"  日均温度: {daily_temp}")\n    \n    print("\\n" + "=" * 60)\n    print("单位系统演示完成！")\n    print("=" * 60)\n',
    "hetao_ag/core/utils.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag.core.utils - 通用工具模块\n\n提供共享的辅助函数和基类。\n\n作者: Hetao College\n版本: 1.0.0\n"""\n\nimport math\nimport numpy as np\nfrom typing import Union, Optional, Callable, Any, List\nfrom dataclasses import dataclass\nfrom datetime import datetime, date\nfrom pathlib import Path\n\n\ndef safe_divide(numerator: float, denominator: float, default: float = 0.0) -> float:\n    """安全除法，避免除零错误\n    \n    参数:\n        numerator: 分子\n        denominator: 分母\n        default: 除零时返回的默认值\n        \n    返回:\n        除法结果或默认值\n        \n    示例:\n        >>> safe_divide(10, 2)\n        5.0\n        >>> safe_divide(10, 0)\n        0.0\n    """\n    if denominator == 0 or math.isnan(denominator):\n        return default\n    return numerator / denominator\n\n\ndef clamp(value: float, min_val: float, max_val: float) -> float:\n    """将值限制在指定范围内\n    \n    参数:\n        value: 输入值\n        min_val: 最小值\n        max_val: 最大值\n        \n    返回:\n        限制后的值\n    """\n    return max(min_val, min(value, max_val))\n\n\ndef linear_interpolate(x: float, x1: float, y1: float, x2: float, y2: float) -> float:\n    """线性插值\n    \n    参数:\n        x: 插值点\n        x1, y1: 第一个已知点\n        x2, y2: 第二个已知点\n        \n    返回:\n        插值结果\n    """\n    if x1 == x2:\n        return y1\n    return y1 + (y2 - y1) * (x - x1) / (x2 - x1)\n\n\ndef array_interpolate(x: float, x_array: np.ndarray, y_array: np.ndarray) -> float:\n    """数组线性插值\n    \n    参数:\n        x: 插值点\n        x_array: x值数组（已排序）\n        y_array: y值数组\n        \n    返回:\n        插值结果\n    """\n    return float(np.interp(x, x_array, y_array))\n\n\ndef day_of_year(dt: Union[datetime, date]) -> int:\n    """获取年内天数（1-365/366）\n    \n    参数:\n        dt: 日期对象\n        \n    返回:\n        年内天数\n    """\n    if isinstance(dt, datetime):\n        dt = dt.date()\n    return dt.timetuple().tm_yday\n\n\ndef degrees_to_radians(degrees: float) -> float:\n    """角度转弧度"""\n    return math.radians(degrees)\n\n\ndef radians_to_degrees(radians: float) -> float:\n    """弧度转角度"""\n    return math.degrees(radians)\n\n\ndef moving_average(data: np.ndarray, window: int) -> np.ndarray:\n    """计算移动平均\n    \n    参数:\n        data: 输入数据数组\n        window: 窗口大小\n        \n    返回:\n        移动平均数组\n    """\n    if window <= 0:\n        raise ValueError("窗口大小必须为正整数")\n    if len(data) < window:\n        return data.copy()\n    \n    return np.convolve(data, np.ones(window) / window, mode=\'valid\')\n\n\ndef normalize(data: np.ndarray, min_val: float = 0.0, max_val: float = 1.0) -> np.ndarray:\n    """将数据归一化到指定范围\n    \n    参数:\n        data: 输入数据\n        min_val: 目标最小值\n        max_val: 目标最大值\n        \n    返回:\n        归一化后的数组\n    """\n    data_min = np.min(data)\n    data_max = np.max(data)\n    \n    if data_max == data_min:\n        return np.full_like(data, (min_val + max_val) / 2, dtype=float)\n    \n    normalized = (data - data_min) / (data_max - data_min)\n    return normalized * (max_val - min_val) + min_val\n\n\ndef rmse(observed: np.ndarray, predicted: np.ndarray) -> float:\n    """计算均方根误差\n    \n    参数:\n        observed: 观测值\n        predicted: 预测值\n        \n    返回:\n        RMSE值\n    """\n    return float(np.sqrt(np.mean((observed - predicted) ** 2)))\n\n\ndef mae(observed: np.ndarray, predicted: np.ndarray) -> float:\n    """计算平均绝对误差\n    \n    参数:\n        observed: 观测值\n        predicted: 预测值\n        \n    返回:\n        MAE值\n    """\n    return float(np.mean(np.abs(observed - predicted)))\n\n\ndef r_squared(observed: np.ndarray, predicted: np.ndarray) -> float:\n    """计算决定系数R²\n    \n    参数:\n        observed: 观测值\n        predicted: 预测值\n        \n    返回:\n        R²值\n    """\n    ss_res = np.sum((observed - predicted) ** 2)\n    ss_tot = np.sum((observed - np.mean(observed)) ** 2)\n    \n    if ss_tot == 0:\n        return 1.0 if ss_res == 0 else 0.0\n    \n    return 1.0 - ss_res / ss_tot\n\n\ndef ensure_path(path: Union[str, Path]) -> Path:\n    """确保路径对象\n    \n    参数:\n        path: 字符串或Path对象\n        \n    返回:\n        Path对象\n    """\n    return Path(path) if isinstance(path, str) else path\n\n\ndef ensure_directory(path: Union[str, Path]) -> Path:\n    """确保目录存在\n    \n    参数:\n        path: 目录路径\n        \n    返回:\n        Path对象\n    """\n    p = ensure_path(path)\n    p.mkdir(parents=True, exist_ok=True)\n    return p\n\n\n@dataclass\nclass ValidationResult:\n    """验证结果数据类\n    \n    属性:\n        rmse: 均方根误差\n        mae: 平均绝对误差\n        r_squared: 决定系数\n        n_samples: 样本数量\n    """\n    rmse: float\n    mae: float\n    r_squared: float\n    n_samples: int\n    \n    def __str__(self) -> str:\n        return (f"验证结果: RMSE={self.rmse:.4f}, MAE={self.mae:.4f}, "\n                f"R^2={self.r_squared:.4f}, N={self.n_samples}")\n\n\ndef validate_model(observed: np.ndarray, predicted: np.ndarray) -> ValidationResult:\n    """模型验证\n    \n    参数:\n        observed: 观测值数组\n        predicted: 预测值数组\n        \n    返回:\n        ValidationResult对象\n    """\n    obs = np.asarray(observed).flatten()\n    pred = np.asarray(predicted).flatten()\n    \n    if len(obs) != len(pred):\n        raise ValueError("观测值和预测值数组长度必须相同")\n    \n    return ValidationResult(\n        rmse=rmse(obs, pred),\n        mae=mae(obs, pred),\n        r_squared=r_squared(obs, pred),\n        n_samples=len(obs)\n    )\n\n\nclass Timer:\n    """计时器上下文管理器\n    \n    示例:\n        >>> with Timer("模型训练"):\n        ...     train_model()\n        模型训练 耗时: 2.34 秒\n    """\n    \n    def __init__(self, name: str = "操作"):\n        self.name = name\n        self.start_time = None\n        self.end_time = None\n    \n    def __enter__(self):\n        self.start_time = datetime.now()\n        return self\n    \n    def __exit__(self, *args):\n        self.end_time = datetime.now()\n        elapsed = (self.end_time - self.start_time).total_seconds()\n        print(f"{self.name} 耗时: {elapsed:.2f} 秒")\n    \n    @property\n    def elapsed(self) -> float:\n        if self.start_time and self.end_time:\n            return (self.end_time - self.start_time).total_seconds()\n        return 0.0\n\n\nif __name__ == "__main__":\n    print("=" * 50)\n    print("河套智慧农牧业库 - 工具函数演示")\n    print("=" * 50)\n    \n    # 安全除法\n    print(f"\\n安全除法: 10/0 = {safe_divide(10, 0)}")\n    \n    # 插值\n    print(f"线性插值: f(1.5) = {linear_interpolate(1.5, 1, 10, 2, 20)}")\n    \n    # 模型验证\n    obs = np.array([1, 2, 3, 4, 5])\n    pred = np.array([1.1, 1.9, 3.1, 3.9, 5.2])\n    result = validate_model(obs, pred)\n    print(f"\\n{result}")\n    \n    # 计时器\n    with Timer("示例计算"):\n        _ = sum(range(1000000))\n',
    "hetao_ag/crop/__init__.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag.crop - 作物模块\n\n作物生长模拟、胁迫响应和物候期管理。\n\n作者: Hetao College\n版本: 1.0.0\n"""\n\nfrom .stress import (\n    yield_reduction_salinity,\n    yield_reduction_salinity_crop,\n    water_stress_factor,\n    water_stress_from_moisture,\n    combined_stress_factor,\n    yield_with_stress,\n    classify_salt_tolerance,\n    CropSaltTolerance,\n    CROP_SALT_TOLERANCE,\n)\n\nfrom .phenology import (\n    PhenologyTracker,\n    PhenologyConfig,\n    GrowthStage,\n    growing_degree_days,\n    CROP_PHENOLOGY,\n)\n\nfrom .growth import (\n    CropModel,\n    CropConfig,\n    simulate_growing_season,\n    CROP_CONFIGS,\n)\n\n__all__ = [\n    # stress\n    "yield_reduction_salinity",\n    "yield_reduction_salinity_crop",\n    "water_stress_factor",\n    "water_stress_from_moisture",\n    "combined_stress_factor",\n    "yield_with_stress",\n    "classify_salt_tolerance",\n    "CropSaltTolerance",\n    "CROP_SALT_TOLERANCE",\n    # phenology\n    "PhenologyTracker",\n    "PhenologyConfig",\n    "GrowthStage",\n    "growing_degree_days",\n    "CROP_PHENOLOGY",\n    # growth\n    "CropModel",\n    "CropConfig",\n    "simulate_growing_season",\n    "CROP_CONFIGS",\n]\n',
    "hetao_ag/crop/growth.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag.crop.growth - 作物生长模型\n\n作物生物量累积和产量模拟。\n\n作者: Hetao College\n版本: 1.0.0\n"""\n\nfrom dataclasses import dataclass, field\nfrom typing import Optional, List, Dict\nimport numpy as np\n\nfrom .stress import yield_reduction_salinity_crop, water_stress_from_moisture, combined_stress_factor\nfrom .phenology import PhenologyTracker, GrowthStage\n\n\n@dataclass\nclass CropConfig:\n    """作物配置参数"""\n    name: str = "wheat"\n    potential_yield_kg_ha: float = 6000.0\n    harvest_index: float = 0.45\n    transpiration_efficiency: float = 20.0  # kg/ha per mm\n    max_lai: float = 5.0\n    salt_threshold: float = 6.0\n    salt_slope: float = 0.071\n\n\n# 预定义作物配置\nCROP_CONFIGS = {\n    "wheat": CropConfig("wheat", 6000, 0.45, 20, 5.0, 6.0, 0.071),\n    "maize": CropConfig("maize", 10000, 0.50, 25, 6.0, 1.7, 0.12),\n    "rice": CropConfig("rice", 8000, 0.50, 15, 7.0, 3.0, 0.12),\n    "cotton": CropConfig("cotton", 4000, 0.35, 18, 4.0, 7.7, 0.052),\n    "sunflower": CropConfig("sunflower", 3000, 0.35, 15, 4.5, 4.8, 0.05),\n}\n\n\nclass CropModel:\n    """作物生长模型\n    \n    模拟作物生物量累积,考虑水分和盐分胁迫。\n    \n    示例:\n        >>> model = CropModel("wheat")\n        >>> for day in range(120):\n        ...     model.update_daily(et=5, soil_moisture=0.25, ECe=3.0)\n        >>> print(f"产量: {model.estimate_yield():.0f} kg/ha")\n    """\n    \n    def __init__(self, crop: str = "wheat", config: Optional[CropConfig] = None):\n        """初始化作物模型\n        \n        参数:\n            crop: 作物类型\n            config: 自定义配置\n        """\n        self.crop = crop\n        self.config = config or CROP_CONFIGS.get(crop, CropConfig())\n        \n        self.phenology = PhenologyTracker(crop)\n        \n        self.accumulated_biomass = 0.0  # kg/ha\n        self.lai = 0.0\n        self.days_after_planting = 0\n        \n        self.daily_biomass: List[float] = []\n        self.stress_history: List[float] = []\n    \n    def update_daily(\n        self,\n        t_max: float = 25.0,\n        t_min: float = 15.0,\n        et: float = 5.0,\n        soil_moisture: float = 0.25,\n        field_capacity: float = 0.32,\n        wilting_point: float = 0.12,\n        ECe: float = 2.0\n    ) -> Dict:\n        """更新一天的生长\n        \n        参数:\n            t_max, t_min: 日最高/最低温度(°C)\n            et: 参考蒸散发(mm/day)\n            soil_moisture: 土壤含水量\n            field_capacity: 田间持水量\n            wilting_point: 凋萎点\n            ECe: 土壤电导率(dS/m)\n            \n        返回:\n            当日生长详情\n        """\n        self.days_after_planting += 1\n        \n        # 更新物候期\n        self.phenology.accumulate_gdd(t_max, t_min)\n        \n        # 获取作物系数\n        kc = self.phenology.get_kc_for_stage()\n        \n        # 计算作物蒸散发\n        etc = et * kc\n        \n        # 水分胁迫\n        ks_water = water_stress_from_moisture(\n            soil_moisture, field_capacity, wilting_point\n        )\n        \n        # 盐分胁迫\n        ks_salt = yield_reduction_salinity_crop(ECe, self.crop)\n        \n        # 组合胁迫\n        ks_combined = combined_stress_factor(ks_water, ks_salt)\n        self.stress_history.append(ks_combined)\n        \n        # 实际蒸散发\n        actual_et = etc * ks_water\n        \n        # 生物量累积(基于蒸腾效率)\n        potential_biomass = self.config.transpiration_efficiency * actual_et\n        actual_biomass = potential_biomass * ks_salt  # 盐分降低生物量转化\n        \n        self.accumulated_biomass += actual_biomass\n        self.daily_biomass.append(self.accumulated_biomass)\n        \n        # 更新LAI(简化模型)\n        progress = self.phenology.progress_to_maturity()\n        if progress < 0.5:\n            self.lai = self.config.max_lai * (progress / 0.5)\n        else:\n            self.lai = self.config.max_lai * (1 - (progress - 0.5) / 0.5)\n        self.lai = max(0, self.lai)\n        \n        return {\n            "day": self.days_after_planting,\n            "stage": self.phenology.current_stage.value,\n            "biomass_kg_ha": self.accumulated_biomass,\n            "lai": self.lai,\n            "stress_factor": ks_combined,\n            "actual_et_mm": actual_et\n        }\n    \n    def estimate_yield(self) -> float:\n        """估算最终产量\n        \n        返回:\n            产量(kg/ha)\n        """\n        # 使用收获指数从生物量估算产量\n        grain_yield = self.accumulated_biomass * self.config.harvest_index\n        \n        # 考虑季节平均胁迫\n        if self.stress_history:\n            avg_stress = np.mean(self.stress_history)\n        else:\n            avg_stress = 1.0\n        \n        # 产量不超过潜在产量\n        return min(grain_yield, self.config.potential_yield_kg_ha * avg_stress)\n    \n    def water_use_efficiency(self, total_et_mm: float) -> float:\n        """计算水分利用效率\n        \n        参数:\n            total_et_mm: 总蒸散发量\n            \n        返回:\n            WUE (kg/m³)\n        """\n        if total_et_mm <= 0:\n            return 0.0\n        \n        yield_kg = self.estimate_yield()\n        water_m3_ha = total_et_mm * 10  # mm to m³/ha\n        \n        return yield_kg / water_m3_ha\n    \n    def reset(self):\n        """重置模型"""\n        self.phenology.reset()\n        self.accumulated_biomass = 0.0\n        self.lai = 0.0\n        self.days_after_planting = 0\n        self.daily_biomass.clear()\n        self.stress_history.clear()\n\n\ndef simulate_growing_season(\n    crop: str,\n    weather: List[Dict],\n    soil_moisture: float = 0.25,\n    ECe: float = 2.0\n) -> Dict:\n    """模拟一个生长季\n    \n    参数:\n        crop: 作物类型\n        weather: 气象数据列表 [{t_max, t_min, et}, ...]\n        soil_moisture: 平均土壤含水量\n        ECe: 土壤电导率\n        \n    返回:\n        模拟结果\n    """\n    model = CropModel(crop)\n    \n    for day_weather in weather:\n        model.update_daily(\n            t_max=day_weather.get("t_max", 25),\n            t_min=day_weather.get("t_min", 15),\n            et=day_weather.get("et", 5),\n            soil_moisture=soil_moisture,\n            ECe=ECe\n        )\n    \n    return {\n        "crop": crop,\n        "days": model.days_after_planting,\n        "final_stage": model.phenology.current_stage.value,\n        "biomass_kg_ha": model.accumulated_biomass,\n        "yield_kg_ha": model.estimate_yield(),\n        "avg_stress": np.mean(model.stress_history) if model.stress_history else 1.0\n    }\n\n\nif __name__ == "__main__":\n    print("=" * 50)\n    print("作物生长模型演示")\n    print("=" * 50)\n    \n    model = CropModel("wheat")\n    \n    # 模拟120天生长季\n    np.random.seed(42)\n    \n    print("\\n逐日模拟:")\n    for day in range(120):\n        t_max = 22 + 10 * np.sin(day / 120 * np.pi) + np.random.randn()\n        t_min = t_max - 10 + np.random.randn()\n        et = 4 + 2 * np.sin(day / 120 * np.pi)\n        \n        result = model.update_daily(\n            t_max=t_max, t_min=t_min, et=et,\n            soil_moisture=0.25, ECe=3.0\n        )\n        \n        if day % 30 == 0:\n            print(f"第{result[\'day\']}天: 阶段={result[\'stage\']}, "\n                  f"生物量={result[\'biomass_kg_ha\']:.0f}kg/ha")\n    \n    final_yield = model.estimate_yield()\n    print(f"\\n最终产量: {final_yield:.0f} kg/ha")\n    print(f"平均胁迫因子: {np.mean(model.stress_history):.3f}")\n',
    "hetao_ag/crop/phenology.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag.crop.phenology - 物候期管理\n\n作物生长期跟踪和积温计算。\n\n作者: Hetao College\n版本: 1.0.0\n"""\n\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom enum import Enum\nimport numpy as np\n\n\nclass GrowthStage(Enum):\n    """生长阶段"""\n    DORMANT = "dormant"\n    EMERGENCE = "emergence"\n    VEGETATIVE = "vegetative"\n    FLOWERING = "flowering"\n    GRAIN_FILL = "grain_fill"\n    MATURITY = "maturity"\n    HARVEST = "harvest"\n\n\n@dataclass\nclass PhenologyConfig:\n    """物候配置\n    \n    属性:\n        base_temperature: 基础温度(°C)\n        stage_gdd: 各阶段所需积温(GDD)\n    """\n    base_temperature: float = 10.0\n    stage_gdd: Dict[str, float] = field(default_factory=lambda: {\n        "emergence": 100,\n        "vegetative": 400,\n        "flowering": 700,\n        "grain_fill": 1100,\n        "maturity": 1500\n    })\n\n\n# 预定义作物物候参数\nCROP_PHENOLOGY = {\n    "wheat": PhenologyConfig(\n        base_temperature=0.0,\n        stage_gdd={"emergence": 120, "vegetative": 450, "flowering": 800, "grain_fill": 1200, "maturity": 1600}\n    ),\n    "maize": PhenologyConfig(\n        base_temperature=10.0,\n        stage_gdd={"emergence": 60, "vegetative": 350, "flowering": 700, "grain_fill": 1100, "maturity": 1400}\n    ),\n    "rice": PhenologyConfig(\n        base_temperature=10.0,\n        stage_gdd={"emergence": 80, "vegetative": 400, "flowering": 650, "grain_fill": 950, "maturity": 1200}\n    ),\n    "cotton": PhenologyConfig(\n        base_temperature=15.5,\n        stage_gdd={"emergence": 80, "vegetative": 500, "flowering": 900, "grain_fill": 1400, "maturity": 1800}\n    ),\n}\n\n\nclass PhenologyTracker:\n    """物候期跟踪器\n    \n    基于积温(GDD)跟踪作物生长阶段。\n    \n    示例:\n        >>> tracker = PhenologyTracker("wheat")\n        >>> tracker.accumulate_gdd(t_max=28, t_min=15)\n        >>> print(tracker.current_stage)\n    """\n    \n    def __init__(self, crop: str = "wheat", config: Optional[PhenologyConfig] = None):\n        """初始化物候跟踪器\n        \n        参数:\n            crop: 作物类型\n            config: 自定义物候配置\n        """\n        self.crop = crop\n        self.config = config or CROP_PHENOLOGY.get(crop, PhenologyConfig())\n        \n        self.accumulated_gdd = 0.0\n        self.days_after_planting = 0\n        self.current_stage = GrowthStage.DORMANT\n        \n        self.gdd_history: List[float] = []\n        self.stage_history: List[GrowthStage] = []\n    \n    def calculate_daily_gdd(self, t_max: float, t_min: float) -> float:\n        """计算日积温(GDD)\n        \n        使用单正弦方法。\n        \n        参数:\n            t_max: 日最高温度(°C)\n            t_min: 日最低温度(°C)\n            \n        返回:\n            日积温\n        """\n        t_base = self.config.base_temperature\n        \n        # 简化方法: (Tmax + Tmin)/2 - Tbase\n        t_mean = (t_max + t_min) / 2\n        gdd = max(0, t_mean - t_base)\n        \n        return gdd\n    \n    def accumulate_gdd(self, t_max: float, t_min: float) -> float:\n        """累积一天的积温并更新阶段\n        \n        参数:\n            t_max: 日最高温\n            t_min: 日最低温\n            \n        返回:\n            当日GDD\n        """\n        daily_gdd = self.calculate_daily_gdd(t_max, t_min)\n        self.accumulated_gdd += daily_gdd\n        self.days_after_planting += 1\n        \n        self.gdd_history.append(self.accumulated_gdd)\n        \n        # 更新生长阶段\n        self._update_stage()\n        self.stage_history.append(self.current_stage)\n        \n        return daily_gdd\n    \n    def _update_stage(self):\n        """更新当前生长阶段"""\n        stage_gdd = self.config.stage_gdd\n        \n        if self.accumulated_gdd >= stage_gdd.get("maturity", float(\'inf\')):\n            self.current_stage = GrowthStage.MATURITY\n        elif self.accumulated_gdd >= stage_gdd.get("grain_fill", float(\'inf\')):\n            self.current_stage = GrowthStage.GRAIN_FILL\n        elif self.accumulated_gdd >= stage_gdd.get("flowering", float(\'inf\')):\n            self.current_stage = GrowthStage.FLOWERING\n        elif self.accumulated_gdd >= stage_gdd.get("vegetative", float(\'inf\')):\n            self.current_stage = GrowthStage.VEGETATIVE\n        elif self.accumulated_gdd >= stage_gdd.get("emergence", float(\'inf\')):\n            self.current_stage = GrowthStage.EMERGENCE\n    \n    def progress_to_maturity(self) -> float:\n        """到成熟期的进度(0-1)"""\n        maturity_gdd = self.config.stage_gdd.get("maturity", 1500)\n        return min(1.0, self.accumulated_gdd / maturity_gdd)\n    \n    def days_to_maturity(self, avg_daily_gdd: float = 15.0) -> int:\n        """估计到成熟期的天数"""\n        maturity_gdd = self.config.stage_gdd.get("maturity", 1500)\n        remaining_gdd = maturity_gdd - self.accumulated_gdd\n        \n        if avg_daily_gdd <= 0:\n            return 999\n        \n        return max(0, int(remaining_gdd / avg_daily_gdd))\n    \n    def get_kc_for_stage(self) -> float:\n        """获取当前阶段的作物系数Kc"""\n        KC_VALUES = {\n            GrowthStage.DORMANT: 0.3,\n            GrowthStage.EMERGENCE: 0.3,\n            GrowthStage.VEGETATIVE: 0.7,\n            GrowthStage.FLOWERING: 1.15,\n            GrowthStage.GRAIN_FILL: 1.1,\n            GrowthStage.MATURITY: 0.4,\n            GrowthStage.HARVEST: 0.3,\n        }\n        return KC_VALUES.get(self.current_stage, 1.0)\n    \n    def reset(self):\n        """重置跟踪器"""\n        self.accumulated_gdd = 0.0\n        self.days_after_planting = 0\n        self.current_stage = GrowthStage.DORMANT\n        self.gdd_history.clear()\n        self.stage_history.clear()\n\n\ndef growing_degree_days(\n    t_max: np.ndarray,\n    t_min: np.ndarray,\n    t_base: float = 10.0,\n    t_upper: float = 30.0\n) -> np.ndarray:\n    """批量计算积温序列\n    \n    参数:\n        t_max: 最高温度数组\n        t_min: 最低温度数组\n        t_base: 基础温度\n        t_upper: 上限温度\n        \n    返回:\n        累积GDD数组\n    """\n    t_max_adj = np.clip(t_max, t_base, t_upper)\n    t_min_adj = np.clip(t_min, t_base, t_upper)\n    \n    daily_gdd = (t_max_adj + t_min_adj) / 2 - t_base\n    daily_gdd = np.maximum(0, daily_gdd)\n    \n    return np.cumsum(daily_gdd)\n\n\nif __name__ == "__main__":\n    print("=" * 50)\n    print("物候期跟踪演示")\n    print("=" * 50)\n    \n    tracker = PhenologyTracker("wheat")\n    \n    # 模拟30天温度\n    np.random.seed(42)\n    temps = [(25 + np.random.randn()*3, 12 + np.random.randn()*2) for _ in range(30)]\n    \n    print("\\n逐日跟踪:")\n    for i, (t_max, t_min) in enumerate(temps, 1):\n        gdd = tracker.accumulate_gdd(t_max, t_min)\n        if i % 10 == 0:\n            print(f"第{i}天: 积温={tracker.accumulated_gdd:.0f}, 阶段={tracker.current_stage.value}")\n    \n    print(f"\\n累积积温: {tracker.accumulated_gdd:.0f}")\n    print(f"当前阶段: {tracker.current_stage.value}")\n    print(f"成熟进度: {tracker.progress_to_maturity()*100:.1f}%")\n    print(f"当前Kc: {tracker.get_kc_for_stage()}")\n',
    "hetao_ag/crop/stress.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag.crop.stress - 作物胁迫响应\n\n水分和盐分胁迫对作物的影响模型。\n\n作者: Hetao College\n版本: 1.0.0\n"""\n\nimport math\nfrom dataclasses import dataclass\nfrom typing import Tuple\n\n\n@dataclass\nclass CropSaltTolerance:\n    """作物盐分耐受性参数\n    \n    基于Maas-Hoffman模型。\n    \n    属性:\n        threshold: ECe阈值(dS/m),低于此值无减产\n        slope: 超过阈值后每dS/m的减产率(0-1)\n    """\n    threshold: float  # dS/m\n    slope: float      # 减产率/dS/m\n\n\n# 常见作物盐分耐受性参数(Maas & Hoffman, 1977)\nCROP_SALT_TOLERANCE = {\n    "wheat": CropSaltTolerance(6.0, 0.071),\n    "maize": CropSaltTolerance(1.7, 0.120),\n    "rice": CropSaltTolerance(3.0, 0.120),\n    "cotton": CropSaltTolerance(7.7, 0.052),\n    "barley": CropSaltTolerance(8.0, 0.050),\n    "sorghum": CropSaltTolerance(6.8, 0.160),\n    "soybean": CropSaltTolerance(5.0, 0.200),\n    "sunflower": CropSaltTolerance(4.8, 0.050),\n    "alfalfa": CropSaltTolerance(2.0, 0.073),\n    "potato": CropSaltTolerance(1.7, 0.120),\n    "tomato": CropSaltTolerance(2.5, 0.095),\n    "pepper": CropSaltTolerance(1.5, 0.140),\n}\n\n\ndef yield_reduction_salinity(ECe: float, threshold: float, slope: float) -> float:\n    """盐分胁迫产量系数\n    \n    Maas-Hoffman线性阈值-斜率模型。\n    \n    参数:\n        ECe: 土壤电导率(dS/m)\n        threshold: 阈值(dS/m)\n        slope: 斜率(减产比例/dS/m)\n        \n    返回:\n        相对产量(0-1)\n        \n    参考:\n        Maas & Hoffman (1977)\n    """\n    if ECe <= threshold:\n        return 1.0\n    \n    reduction = slope * (ECe - threshold)\n    relative_yield = 1.0 - reduction\n    \n    return max(0.0, relative_yield)\n\n\ndef yield_reduction_salinity_crop(ECe: float, crop: str) -> float:\n    """根据作物类型计算盐分胁迫\n    \n    参数:\n        ECe: 土壤电导率(dS/m)\n        crop: 作物名称\n        \n    返回:\n        相对产量(0-1)\n    """\n    tolerance = CROP_SALT_TOLERANCE.get(crop.lower())\n    if tolerance is None:\n        # 默认使用中等敏感作物参数\n        tolerance = CropSaltTolerance(4.0, 0.10)\n    \n    return yield_reduction_salinity(ECe, tolerance.threshold, tolerance.slope)\n\n\ndef water_stress_factor(\n    actual_et: float,\n    potential_et: float,\n    p: float = 0.5\n) -> float:\n    """水分胁迫因子\n    \n    参数:\n        actual_et: 实际蒸散发\n        potential_et: 潜在蒸散发\n        p: 可耗水量系数(默认0.5)\n        \n    返回:\n        水分胁迫因子Ks (0-1)\n    """\n    if potential_et <= 0:\n        return 1.0\n    \n    ratio = actual_et / potential_et\n    return min(1.0, max(0.0, ratio))\n\n\ndef water_stress_from_moisture(\n    soil_moisture: float,\n    field_capacity: float,\n    wilting_point: float,\n    p: float = 0.5\n) -> float:\n    """基于土壤水分的胁迫因子\n    \n    当土壤水分低于临界点时产生胁迫。\n    \n    参数:\n        soil_moisture: 当前含水量\n        field_capacity: 田间持水量\n        wilting_point: 凋萎点\n        p: 可耗水量系数\n        \n    返回:\n        Ks (0-1)\n    """\n    taw = field_capacity - wilting_point  # 总可用水\n    raw = p * taw  # 易可用水\n    \n    if soil_moisture >= field_capacity - raw:\n        return 1.0\n    elif soil_moisture <= wilting_point:\n        return 0.0\n    else:\n        # 在raw和凋萎点之间线性下降\n        return (soil_moisture - wilting_point) / (field_capacity - raw - wilting_point + taw * (1 - p))\n\n\ndef combined_stress_factor(\n    water_stress: float,\n    salinity_stress: float,\n    method: str = "multiplicative"\n) -> float:\n    """组合胁迫因子\n    \n    参数:\n        water_stress: 水分胁迫因子\n        salinity_stress: 盐分胁迫因子\n        method: 组合方法(multiplicative, minimum, additive)\n        \n    返回:\n        组合胁迫因子(0-1)\n    """\n    if method == "multiplicative":\n        return water_stress * salinity_stress\n    elif method == "minimum":\n        return min(water_stress, salinity_stress)\n    elif method == "additive":\n        return max(0, 1 - (1 - water_stress) - (1 - salinity_stress))\n    else:\n        return water_stress * salinity_stress\n\n\ndef yield_with_stress(\n    potential_yield: float,\n    water_stress: float = 1.0,\n    salinity_stress: float = 1.0,\n    other_stress: float = 1.0\n) -> float:\n    """计算胁迫条件下的产量\n    \n    参数:\n        potential_yield: 潜在产量(kg/ha)\n        water_stress: 水分胁迫因子\n        salinity_stress: 盐分胁迫因子\n        other_stress: 其他胁迫因子\n        \n    返回:\n        实际产量(kg/ha)\n    """\n    stress = water_stress * salinity_stress * other_stress\n    return potential_yield * stress\n\n\ndef classify_salt_tolerance(crop: str) -> str:\n    """作物盐分耐受性分级\n    \n    参数:\n        crop: 作物名称\n        \n    返回:\n        耐盐等级描述\n    """\n    tolerance = CROP_SALT_TOLERANCE.get(crop.lower())\n    if tolerance is None:\n        return "未知"\n    \n    threshold = tolerance.threshold\n    \n    if threshold >= 8.0:\n        return "高度耐盐"\n    elif threshold >= 6.0:\n        return "中度耐盐"\n    elif threshold >= 4.0:\n        return "轻度耐盐"\n    elif threshold >= 2.0:\n        return "敏感"\n    else:\n        return "非常敏感"\n\n\nif __name__ == "__main__":\n    print("=" * 50)\n    print("作物胁迫响应演示")\n    print("=" * 50)\n    \n    # 盐分胁迫\n    print("\\n【盐分胁迫】")\n    crops = ["wheat", "maize", "cotton", "barley"]\n    ECe = 8.0\n    \n    for crop in crops:\n        rel_yield = yield_reduction_salinity_crop(ECe, crop)\n        tolerance = classify_salt_tolerance(crop)\n        print(f"  {crop}: ECe={ECe} dS/m时产量={rel_yield*100:.1f}% ({tolerance})")\n    \n    # 水分胁迫\n    print("\\n【水分胁迫】")\n    ks = water_stress_from_moisture(0.18, 0.32, 0.12, p=0.5)\n    print(f"  土壤含水量0.18时Ks={ks:.3f}")\n    \n    # 组合胁迫\n    print("\\n【组合胁迫】")\n    combined = combined_stress_factor(ks, 0.85)\n    yield_actual = yield_with_stress(5000, ks, 0.85)\n    print(f"  组合因子={combined:.3f}")\n    print(f"  潜在产量5000kg/ha -> 实际{yield_actual:.0f}kg/ha")\n',
    "hetao_ag/livestock/__init__.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag.livestock - 畜牧模块\n\n动物检测、行为分类和健康监测。\n\n作者: Hetao College\n版本: 1.0.0\n"""\n\nfrom .vision import (\n    AnimalDetector,\n    Detection,\n    calculate_iou,\n)\n\nfrom .behavior import (\n    BehaviorClassifier,\n    AnimalBehavior,\n    BehaviorRecord,\n    ActivityMonitor,\n)\n\nfrom .health import (\n    HealthMonitor,\n    HerdHealthMonitor,\n    HealthAlert,\n    HealthStatus,\n    AlertType,\n)\n\n__all__ = [\n    # vision\n    "AnimalDetector",\n    "Detection",\n    "calculate_iou",\n    # behavior\n    "BehaviorClassifier",\n    "AnimalBehavior",\n    "BehaviorRecord",\n    "ActivityMonitor",\n    # health\n    "HealthMonitor",\n    "HerdHealthMonitor",\n    "HealthAlert",\n    "HealthStatus",\n    "AlertType",\n]\n',
    "hetao_ag/livestock/behavior.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag.livestock.behavior - 行为分类\n\n动物行为识别和分类。\n\n作者: Hetao College\n版本: 1.0.0\n"""\n\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom enum import Enum\nimport numpy as np\n\n\nclass AnimalBehavior(Enum):\n    """动物行为类型"""\n    STANDING = "standing"\n    LYING = "lying"\n    WALKING = "walking"\n    GRAZING = "grazing"\n    DRINKING = "drinking"\n    RUMINATING = "ruminating"\n    RUNNING = "running"\n    ABNORMAL = "abnormal"\n\n\n@dataclass\nclass BehaviorRecord:\n    """行为记录"""\n    timestamp: float\n    animal_id: Optional[str]\n    behavior: AnimalBehavior\n    confidence: float\n    duration_seconds: float = 0.0\n\n\nclass BehaviorClassifier:\n    """行为分类器\n    \n    从视频或传感器数据分类动物行为。\n    \n    示例:\n        >>> classifier = BehaviorClassifier()\n        >>> behavior = classifier.classify_from_motion(motion_data)\n    """\n    \n    def __init__(self, model_path: Optional[str] = None):\n        """初始化分类器"""\n        self.model_path = model_path\n        self.model = None\n        \n        # 行为识别阈值\n        self.thresholds = {\n            "motion_low": 0.1,\n            "motion_high": 0.5,\n            "head_down": 0.3,\n        }\n    \n    def classify_from_motion(\n        self,\n        motion_magnitude: float,\n        head_position: Optional[str] = None\n    ) -> AnimalBehavior:\n        """基于运动特征分类行为\n        \n        参数:\n            motion_magnitude: 运动幅度(0-1)\n            head_position: 头部位置(up, down, level)\n            \n        返回:\n            行为类别\n        """\n        if motion_magnitude < self.thresholds["motion_low"]:\n            if head_position == "down":\n                return AnimalBehavior.RUMINATING\n            return AnimalBehavior.LYING\n        \n        elif motion_magnitude < self.thresholds["motion_high"]:\n            if head_position == "down":\n                return AnimalBehavior.GRAZING\n            return AnimalBehavior.STANDING\n        \n        else:\n            return AnimalBehavior.WALKING\n    \n    def classify_sequence(self, frames: List) -> AnimalBehavior:\n        """从帧序列分类行为\n        \n        参数:\n            frames: 视频帧列表\n            \n        返回:\n            行为类别\n        """\n        # 简化实现:分析帧间运动\n        if len(frames) < 2:\n            return AnimalBehavior.STANDING\n        \n        # 计算帧间差异(模拟)\n        motion = np.random.random()  # 实际应计算光流\n        \n        return self.classify_from_motion(motion)\n    \n    def analyze_daily_pattern(\n        self,\n        records: List[BehaviorRecord]\n    ) -> Dict[str, float]:\n        """分析日行为模式\n        \n        参数:\n            records: 行为记录列表\n            \n        返回:\n            各行为时间占比\n        """\n        total_time = sum(r.duration_seconds for r in records)\n        if total_time == 0:\n            return {}\n        \n        pattern = {}\n        for behavior in AnimalBehavior:\n            time = sum(r.duration_seconds for r in records if r.behavior == behavior)\n            pattern[behavior.value] = time / total_time\n        \n        return pattern\n\n\nclass ActivityMonitor:\n    """活动量监测器\n    \n    基于加速度计或计步器数据监测动物活动量。\n    """\n    \n    def __init__(self, animal_id: str):\n        self.animal_id = animal_id\n        self.activity_history: List[float] = []\n        self.baseline: Optional[float] = None\n    \n    def add_reading(self, activity_level: float):\n        """添加活动量读数"""\n        self.activity_history.append(activity_level)\n        \n        # 更新基线(使用滑动平均)\n        if len(self.activity_history) >= 7:\n            self.baseline = np.mean(self.activity_history[-7:])\n    \n    def get_daily_activity(self) -> float:\n        """获取日活动量"""\n        if not self.activity_history:\n            return 0.0\n        return self.activity_history[-1]\n    \n    def detect_anomaly(self, threshold: float = 0.3) -> bool:\n        """检测活动异常\n        \n        参数:\n            threshold: 异常阈值(相对偏差)\n            \n        返回:\n            是否异常\n        """\n        if self.baseline is None or len(self.activity_history) < 2:\n            return False\n        \n        current = self.activity_history[-1]\n        deviation = abs(current - self.baseline) / self.baseline\n        \n        return deviation > threshold\n\n\nif __name__ == "__main__":\n    print("=" * 50)\n    print("行为分类演示")\n    print("=" * 50)\n    \n    classifier = BehaviorClassifier()\n    \n    # 测试分类\n    test_cases = [\n        (0.05, "down"),\n        (0.2, "level"),\n        (0.3, "down"),\n        (0.7, None),\n    ]\n    \n    print("\\n行为分类测试:")\n    for motion, head in test_cases:\n        behavior = classifier.classify_from_motion(motion, head)\n        print(f"  运动={motion:.2f}, 头位置={head} -> {behavior.value}")\n    \n    # 活动监测\n    monitor = ActivityMonitor("cow_001")\n    for day in range(10):\n        activity = 100 + np.random.randn() * 10\n        monitor.add_reading(activity)\n    \n    print(f"\\n日活动量: {monitor.get_daily_activity():.1f}")\n    print(f"基线: {monitor.baseline:.1f}")\n',
    "hetao_ag/livestock/health.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag.livestock.health - 健康监测\n\n动物健康和福利监测预警。\n\n作者: Hetao College\n版本: 1.0.0\n"""\n\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom enum import Enum\nfrom datetime import datetime\nimport numpy as np\n\n\nclass HealthStatus(Enum):\n    """健康状态"""\n    HEALTHY = "healthy"\n    ATTENTION = "attention"\n    WARNING = "warning"\n    CRITICAL = "critical"\n\n\nclass AlertType(Enum):\n    """预警类型"""\n    REDUCED_ACTIVITY = "reduced_activity"\n    REDUCED_FEEDING = "reduced_feeding"\n    ABNORMAL_BEHAVIOR = "abnormal_behavior"\n    TEMPERATURE = "temperature"\n    LAMENESS = "lameness"\n    HEAT_DETECTION = "heat_detection"\n\n\n@dataclass\nclass HealthAlert:\n    """健康预警"""\n    animal_id: str\n    alert_type: AlertType\n    severity: HealthStatus\n    message: str\n    timestamp: datetime\n    value: Optional[float] = None\n\n\nclass HealthMonitor:\n    """健康监测器\n    \n    综合多源数据监测动物健康状态。\n    \n    示例:\n        >>> monitor = HealthMonitor("cow_001")\n        >>> monitor.update_activity(85)\n        >>> monitor.update_feeding_time(180)\n        >>> alerts = monitor.check_health()\n    """\n    \n    def __init__(self, animal_id: str):\n        self.animal_id = animal_id\n        \n        # 历史数据\n        self.activity_history: List[float] = []\n        self.feeding_history: List[float] = []\n        self.temperature_history: List[float] = []\n        \n        # 基线值\n        self.activity_baseline: Optional[float] = None\n        self.feeding_baseline: Optional[float] = None\n        \n        # 预警阈值\n        self.thresholds = {\n            "activity_drop": 0.30,  # 活动量下降30%\n            "feeding_drop": 0.25,   # 采食时间下降25%\n            "temp_high": 39.5,      # 高温阈值(°C)\n            "temp_low": 37.5,       # 低温阈值(°C)\n        }\n        \n        self.alerts: List[HealthAlert] = []\n    \n    def update_activity(self, value: float):\n        """更新活动量"""\n        self.activity_history.append(value)\n        if len(self.activity_history) >= 7:\n            self.activity_baseline = np.mean(self.activity_history[-7:-1])\n    \n    def update_feeding_time(self, minutes: float):\n        """更新采食时间(分钟)"""\n        self.feeding_history.append(minutes)\n        if len(self.feeding_history) >= 7:\n            self.feeding_baseline = np.mean(self.feeding_history[-7:-1])\n    \n    def update_temperature(self, temp_celsius: float):\n        """更新体温"""\n        self.temperature_history.append(temp_celsius)\n    \n    def check_health(self) -> List[HealthAlert]:\n        """检查健康状态并生成预警"""\n        alerts = []\n        now = datetime.now()\n        \n        # 检查活动量\n        if self.activity_baseline and len(self.activity_history) > 0:\n            current = self.activity_history[-1]\n            if current < self.activity_baseline * (1 - self.thresholds["activity_drop"]):\n                drop_percent = (1 - current / self.activity_baseline) * 100\n                alerts.append(HealthAlert(\n                    animal_id=self.animal_id,\n                    alert_type=AlertType.REDUCED_ACTIVITY,\n                    severity=HealthStatus.WARNING if drop_percent > 40 else HealthStatus.ATTENTION,\n                    message=f"活动量下降{drop_percent:.0f}%",\n                    timestamp=now,\n                    value=current\n                ))\n        \n        # 检查采食\n        if self.feeding_baseline and len(self.feeding_history) > 0:\n            current = self.feeding_history[-1]\n            if current < self.feeding_baseline * (1 - self.thresholds["feeding_drop"]):\n                drop_percent = (1 - current / self.feeding_baseline) * 100\n                alerts.append(HealthAlert(\n                    animal_id=self.animal_id,\n                    alert_type=AlertType.REDUCED_FEEDING,\n                    severity=HealthStatus.WARNING,\n                    message=f"采食时间下降{drop_percent:.0f}%",\n                    timestamp=now,\n                    value=current\n                ))\n        \n        # 检查体温\n        if len(self.temperature_history) > 0:\n            temp = self.temperature_history[-1]\n            if temp > self.thresholds["temp_high"]:\n                alerts.append(HealthAlert(\n                    animal_id=self.animal_id,\n                    alert_type=AlertType.TEMPERATURE,\n                    severity=HealthStatus.CRITICAL if temp > 40.5 else HealthStatus.WARNING,\n                    message=f"体温异常: {temp:.1f}°C",\n                    timestamp=now,\n                    value=temp\n                ))\n        \n        self.alerts.extend(alerts)\n        return alerts\n    \n    def get_status(self) -> HealthStatus:\n        """获取当前健康状态"""\n        if not self.alerts:\n            return HealthStatus.HEALTHY\n        \n        recent_alerts = [a for a in self.alerts[-10:]]\n        severities = [a.severity for a in recent_alerts]\n        \n        if HealthStatus.CRITICAL in severities:\n            return HealthStatus.CRITICAL\n        elif HealthStatus.WARNING in severities:\n            return HealthStatus.WARNING\n        elif HealthStatus.ATTENTION in severities:\n            return HealthStatus.ATTENTION\n        \n        return HealthStatus.HEALTHY\n\n\nclass HerdHealthMonitor:\n    """群体健康监测"""\n    \n    def __init__(self):\n        self.animals: Dict[str, HealthMonitor] = {}\n    \n    def add_animal(self, animal_id: str):\n        """添加监测动物"""\n        self.animals[animal_id] = HealthMonitor(animal_id)\n    \n    def get_monitor(self, animal_id: str) -> Optional[HealthMonitor]:\n        """获取个体监测器"""\n        return self.animals.get(animal_id)\n    \n    def check_all(self) -> List[HealthAlert]:\n        """检查所有动物"""\n        all_alerts = []\n        for monitor in self.animals.values():\n            all_alerts.extend(monitor.check_health())\n        return all_alerts\n    \n    def get_summary(self) -> Dict[str, int]:\n        """获取健康状态汇总"""\n        summary = {status.value: 0 for status in HealthStatus}\n        for monitor in self.animals.values():\n            status = monitor.get_status()\n            summary[status.value] += 1\n        return summary\n\n\nif __name__ == "__main__":\n    print("=" * 50)\n    print("健康监测演示")\n    print("=" * 50)\n    \n    monitor = HealthMonitor("cow_001")\n    \n    # 模拟正常数据\n    for _ in range(7):\n        monitor.update_activity(100 + np.random.randn() * 5)\n        monitor.update_feeding_time(240 + np.random.randn() * 10)\n    \n    # 添加异常数据\n    monitor.update_activity(60)  # 活动量下降\n    monitor.update_temperature(40.2)  # 发烧\n    \n    alerts = monitor.check_health()\n    \n    print(f"\\n当前状态: {monitor.get_status().value}")\n    print(f"\\n预警数量: {len(alerts)}")\n    for alert in alerts:\n        print(f"  [{alert.severity.value}] {alert.alert_type.value}: {alert.message}")\n',
    "hetao_ag/livestock/vision.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag.livestock.vision - 动物视觉检测\n\n基于深度学习的动物检测和计数。\n\n作者: Hetao College\n版本: 1.0.0\n"""\n\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Tuple, Dict\nimport numpy as np\n\n\n@dataclass\nclass Detection:\n    """检测结果"""\n    bbox: Tuple[float, float, float, float]  # x1, y1, x2, y2\n    confidence: float\n    class_id: int\n    label: str\n\n\nclass AnimalDetector:\n    """动物检测器\n    \n    基于YOLO的动物检测,支持边缘设备部署。\n    \n    示例:\n        >>> detector = AnimalDetector()\n        >>> detections = detector.detect("farm_image.jpg")\n        >>> cows = [d for d in detections if d.label == "cow"]\n    """\n    \n    SUPPORTED_ANIMALS = ["cow", "sheep", "goat", "horse", "pig", "chicken"]\n    \n    def __init__(\n        self,\n        model_name: str = "yolov5s",\n        confidence_threshold: float = 0.5,\n        use_gpu: bool = True\n    ):\n        """初始化检测器\n        \n        参数:\n            model_name: 模型名称\n            confidence_threshold: 置信度阈值\n            use_gpu: 是否使用GPU\n        """\n        self.model_name = model_name\n        self.confidence_threshold = confidence_threshold\n        self.use_gpu = use_gpu\n        self.model = None\n        self._model_loaded = False\n    \n    def load_model(self):\n        """加载检测模型"""\n        try:\n            import torch\n            self.model = torch.hub.load(\'ultralytics/yolov5\', self.model_name, pretrained=True)\n            \n            if self.use_gpu and torch.cuda.is_available():\n                self.model.to(\'cuda\')\n                try:\n                    self.model.half()\n                except:\n                    pass\n            \n            self._model_loaded = True\n        except ImportError:\n            print("警告: PyTorch未安装,使用模拟模式")\n            self._model_loaded = False\n    \n    def detect(self, image) -> List[Detection]:\n        """检测图像中的动物\n        \n        参数:\n            image: 图像路径、numpy数组或URL\n            \n        返回:\n            Detection列表\n        """\n        if not self._model_loaded:\n            # 模拟检测结果\n            return self._simulate_detection()\n        \n        results = self.model(image)\n        detections = []\n        \n        for *bbox, conf, cls_idx in results.xyxy[0].tolist():\n            label = results.names[int(cls_idx)]\n            \n            if conf >= self.confidence_threshold:\n                detections.append(Detection(\n                    bbox=tuple(bbox),\n                    confidence=conf,\n                    class_id=int(cls_idx),\n                    label=label\n                ))\n        \n        return detections\n    \n    def _simulate_detection(self) -> List[Detection]:\n        """模拟检测结果(用于测试)"""\n        return [\n            Detection((100, 100, 300, 300), 0.95, 0, "cow"),\n            Detection((400, 150, 550, 350), 0.87, 0, "cow"),\n        ]\n    \n    def count_animals(self, image, species: Optional[str] = None) -> Dict[str, int]:\n        """统计动物数量\n        \n        参数:\n            image: 输入图像\n            species: 指定物种(可选)\n            \n        返回:\n            各物种数量字典\n        """\n        detections = self.detect(image)\n        \n        counts = {}\n        for det in detections:\n            if species and det.label != species:\n                continue\n            counts[det.label] = counts.get(det.label, 0) + 1\n        \n        return counts\n\n\ndef calculate_iou(box1: Tuple, box2: Tuple) -> float:\n    """计算两个边界框的IoU\n    \n    参数:\n        box1, box2: (x1, y1, x2, y2)格式的边界框\n        \n    返回:\n        IoU值(0-1)\n    """\n    x1 = max(box1[0], box2[0])\n    y1 = max(box1[1], box2[1])\n    x2 = min(box1[2], box2[2])\n    y2 = min(box1[3], box2[3])\n    \n    intersection = max(0, x2 - x1) * max(0, y2 - y1)\n    \n    area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n    area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n    \n    union = area1 + area2 - intersection\n    \n    return intersection / union if union > 0 else 0\n\n\nif __name__ == "__main__":\n    print("=" * 50)\n    print("动物视觉检测演示")\n    print("=" * 50)\n    \n    detector = AnimalDetector(confidence_threshold=0.5)\n    \n    # 模拟检测\n    detections = detector.detect("test_image.jpg")\n    \n    print(f"\\n检测到 {len(detections)} 个目标:")\n    for det in detections:\n        print(f"  {det.label}: 置信度={det.confidence:.2f}, 位置={det.bbox}")\n    \n    counts = detector.count_animals("test_image.jpg")\n    print(f"\\n动物计数: {counts}")\n',
    "hetao_ag/opt/__init__.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag.opt - 优化模块\n\n农业资源优化和决策支持。\n\n作者: Hetao College\n版本: 1.0.0\n"""\n\nfrom .linear import (\n    LinearOptimizer,\n    OptimizationResult,\n    optimize_crop_mix,\n)\n\nfrom .genetic import (\n    GeneticOptimizer,\n    GAConfig,\n    GAResult,\n    optimize_irrigation_schedule,\n)\n\nfrom .planning import (\n    ScenarioEvaluator,\n    FarmScenario,\n    multi_objective_score,\n)\n\n__all__ = [\n    # linear\n    "LinearOptimizer",\n    "OptimizationResult",\n    "optimize_crop_mix",\n    # genetic\n    "GeneticOptimizer",\n    "GAConfig",\n    "GAResult",\n    "optimize_irrigation_schedule",\n    # planning\n    "ScenarioEvaluator",\n    "FarmScenario",\n    "multi_objective_score",\n]\n',
    "hetao_ag/opt/genetic.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag.opt.genetic - 遗传算法\n\n农业优化问题的遗传算法实现。\n\n作者: Hetao College\n版本: 1.0.0\n"""\n\nimport random\nimport numpy as np\nfrom dataclasses import dataclass\nfrom typing import List, Callable, Optional, Tuple\n\n\n@dataclass\nclass GAConfig:\n    """遗传算法配置"""\n    population_size: int = 50\n    generations: int = 100\n    crossover_rate: float = 0.8\n    mutation_rate: float = 0.1\n    elitism: int = 2\n    tournament_size: int = 3\n\n\n@dataclass\nclass GAResult:\n    """遗传算法结果"""\n    best_solution: List[float]\n    best_fitness: float\n    generations_run: int\n    fitness_history: List[float]\n\n\nclass GeneticOptimizer:\n    """遗传算法优化器\n    \n    示例:\n        >>> def fitness(x):\n        ...     return -(x[0]**2 + x[1]**2)\n        >>> optimizer = GeneticOptimizer(fitness, n_vars=2, bounds=[(-5,5), (-5,5)])\n        >>> result = optimizer.optimize()\n    """\n    \n    def __init__(\n        self,\n        fitness_func: Callable[[List[float]], float],\n        n_vars: int,\n        bounds: List[Tuple[float, float]],\n        config: Optional[GAConfig] = None\n    ):\n        self.fitness_func = fitness_func\n        self.n_vars = n_vars\n        self.bounds = bounds\n        self.config = config or GAConfig()\n        \n        self.population: List[List[float]] = []\n        self.fitness_values: List[float] = []\n    \n    def _initialize_population(self):\n        """初始化种群"""\n        self.population = []\n        for _ in range(self.config.population_size):\n            individual = [\n                random.uniform(low, high)\n                for low, high in self.bounds\n            ]\n            self.population.append(individual)\n    \n    def _evaluate_population(self):\n        """评估种群适应度"""\n        self.fitness_values = [self.fitness_func(ind) for ind in self.population]\n    \n    def _tournament_select(self) -> List[float]:\n        """锦标赛选择"""\n        indices = random.sample(range(len(self.population)), self.config.tournament_size)\n        best_idx = max(indices, key=lambda i: self.fitness_values[i])\n        return self.population[best_idx].copy()\n    \n    def _crossover(self, parent1: List[float], parent2: List[float]) -> Tuple[List[float], List[float]]:\n        """交叉操作"""\n        if random.random() > self.config.crossover_rate:\n            return parent1.copy(), parent2.copy()\n        \n        # 单点交叉\n        point = random.randint(1, self.n_vars - 1)\n        child1 = parent1[:point] + parent2[point:]\n        child2 = parent2[:point] + parent1[point:]\n        \n        return child1, child2\n    \n    def _mutate(self, individual: List[float]) -> List[float]:\n        """变异操作"""\n        result = individual.copy()\n        for i in range(self.n_vars):\n            if random.random() < self.config.mutation_rate:\n                low, high = self.bounds[i]\n                result[i] = random.uniform(low, high)\n        return result\n    \n    def _clip_bounds(self, individual: List[float]) -> List[float]:\n        """边界约束"""\n        return [\n            max(low, min(high, val))\n            for val, (low, high) in zip(individual, self.bounds)\n        ]\n    \n    def optimize(self) -> GAResult:\n        """运行优化"""\n        self._initialize_population()\n        self._evaluate_population()\n        \n        fitness_history = []\n        \n        for gen in range(self.config.generations):\n            # 记录当代最佳\n            best_fitness = max(self.fitness_values)\n            fitness_history.append(best_fitness)\n            \n            # 精英保留\n            elite_indices = sorted(range(len(self.fitness_values)),\n                                  key=lambda i: self.fitness_values[i],\n                                  reverse=True)[:self.config.elitism]\n            new_population = [self.population[i].copy() for i in elite_indices]\n            \n            # 生成新个体\n            while len(new_population) < self.config.population_size:\n                parent1 = self._tournament_select()\n                parent2 = self._tournament_select()\n                \n                child1, child2 = self._crossover(parent1, parent2)\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n                child1 = self._clip_bounds(child1)\n                child2 = self._clip_bounds(child2)\n                \n                new_population.extend([child1, child2])\n            \n            self.population = new_population[:self.config.population_size]\n            self._evaluate_population()\n        \n        # 最终结果\n        best_idx = max(range(len(self.fitness_values)), key=lambda i: self.fitness_values[i])\n        \n        return GAResult(\n            best_solution=self.population[best_idx],\n            best_fitness=self.fitness_values[best_idx],\n            generations_run=self.config.generations,\n            fitness_history=fitness_history\n        )\n\n\ndef optimize_irrigation_schedule(\n    daily_et: np.ndarray,\n    max_irrigation: float = 50,\n    min_interval: int = 3\n) -> Tuple[np.ndarray, float]:\n    """优化灌溉计划\n    \n    参数:\n        daily_et: 逐日ET需求\n        max_irrigation: 单次最大灌溉量\n        min_interval: 最小灌溉间隔\n        \n    返回:\n        (灌溉计划, 总水量)\n    """\n    n_days = len(daily_et)\n    \n    def fitness(schedule):\n        # 评估灌溉计划\n        soil_water = 100  # 初始土壤水分\n        stress_days = 0\n        total_irrig = 0\n        \n        for i, (et, irrig) in enumerate(zip(daily_et, schedule)):\n            soil_water += irrig * max_irrigation\n            soil_water -= et\n            total_irrig += irrig * max_irrigation\n            \n            if soil_water < 30:  # 胁迫阈值\n                stress_days += 1\n                soil_water = max(0, soil_water)\n        \n        return -stress_days - total_irrig * 0.01\n    \n    bounds = [(0, 1) for _ in range(n_days)]\n    optimizer = GeneticOptimizer(fitness, n_days, bounds, GAConfig(generations=50))\n    result = optimizer.optimize()\n    \n    schedule = np.array(result.best_solution)\n    schedule = (schedule > 0.5).astype(float) * max_irrigation\n    \n    return schedule, np.sum(schedule)\n\n\nif __name__ == "__main__":\n    print("=" * 50)\n    print("遗传算法优化演示")\n    print("=" * 50)\n    \n    # 测试函数: 球函数最小化\n    def sphere(x):\n        return -sum(xi**2 for xi in x)\n    \n    bounds = [(-5, 5) for _ in range(3)]\n    optimizer = GeneticOptimizer(sphere, 3, bounds, GAConfig(generations=50))\n    result = optimizer.optimize()\n    \n    print(f"\\n最优解: {[f\'{x:.4f}\' for x in result.best_solution]}")\n    print(f"最优适应度: {result.best_fitness:.6f}")\n    print(f"运行代数: {result.generations_run}")\n',
    "hetao_ag/opt/linear.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag.opt.linear - 线性规划\n\n农业资源优化的线性规划工具。\n\n作者: Hetao College\n版本: 1.0.0\n"""\n\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional, Any\nimport numpy as np\n\n\n@dataclass\nclass OptimizationResult:\n    """优化结果"""\n    status: str\n    objective_value: float\n    variables: Dict[str, float]\n    message: str = ""\n\n\nclass LinearOptimizer:\n    """线性规划优化器\n    \n    示例:\n        >>> optimizer = LinearOptimizer()\n        >>> optimizer.add_variable("wheat_area", 0, 100)\n        >>> optimizer.add_variable("maize_area", 0, 100)\n        >>> optimizer.set_objective({"wheat_area": 500, "maize_area": 600}, maximize=True)\n        >>> optimizer.add_constraint({"wheat_area": 1, "maize_area": 1}, "<=", 150)\n        >>> result = optimizer.solve()\n    """\n    \n    def __init__(self):\n        self.variables: Dict[str, tuple] = {}  # name: (lower, upper)\n        self.objective: Dict[str, float] = {}\n        self.maximize = True\n        self.constraints: List[tuple] = []  # (coeffs, sense, rhs)\n    \n    def add_variable(self, name: str, lower: float = 0, upper: float = None):\n        """添加决策变量"""\n        self.variables[name] = (lower, upper)\n    \n    def set_objective(self, coefficients: Dict[str, float], maximize: bool = True):\n        """设置目标函数"""\n        self.objective = coefficients\n        self.maximize = maximize\n    \n    def add_constraint(self, coefficients: Dict[str, float], sense: str, rhs: float):\n        """添加约束\n        \n        参数:\n            coefficients: 变量系数\n            sense: "<=", ">=", "=="\n            rhs: 右侧常数\n        """\n        self.constraints.append((coefficients, sense, rhs))\n    \n    def solve(self) -> OptimizationResult:\n        """求解优化问题"""\n        try:\n            import pulp\n            return self._solve_pulp()\n        except ImportError:\n            return self._solve_simple()\n    \n    def _solve_pulp(self) -> OptimizationResult:\n        """使用PuLP求解"""\n        import pulp\n        \n        sense = pulp.LpMaximize if self.maximize else pulp.LpMinimize\n        prob = pulp.LpProblem("AgOptimization", sense)\n        \n        # 创建变量\n        lp_vars = {}\n        for name, (lower, upper) in self.variables.items():\n            lp_vars[name] = pulp.LpVariable(name, lowBound=lower, upBound=upper)\n        \n        # 目标函数\n        prob += pulp.lpSum(coeff * lp_vars[name] for name, coeff in self.objective.items())\n        \n        # 约束\n        for coeffs, sense_str, rhs in self.constraints:\n            expr = pulp.lpSum(c * lp_vars[n] for n, c in coeffs.items())\n            if sense_str == "<=":\n                prob += expr <= rhs\n            elif sense_str == ">=":\n                prob += expr >= rhs\n            else:\n                prob += expr == rhs\n        \n        # 求解\n        prob.solve(pulp.PULP_CBC_CMD(msg=0))\n        \n        return OptimizationResult(\n            status=pulp.LpStatus[prob.status],\n            objective_value=pulp.value(prob.objective),\n            variables={name: var.value() for name, var in lp_vars.items()},\n            message=""\n        )\n    \n    def _solve_simple(self) -> OptimizationResult:\n        """简单求解(无PuLP时)"""\n        # 返回边界可行解作为近似\n        variables = {}\n        for name, (lower, upper) in self.variables.items():\n            if self.maximize:\n                variables[name] = upper if upper else 100\n            else:\n                variables[name] = lower\n        \n        obj_value = sum(self.objective.get(n, 0) * v for n, v in variables.items())\n        \n        return OptimizationResult(\n            status="Approximate",\n            objective_value=obj_value,\n            variables=variables,\n            message="PuLP未安装,使用简单近似"\n        )\n\n\ndef optimize_crop_mix(\n    crops: List[Dict],\n    total_land: float,\n    total_water: float\n) -> Dict[str, float]:\n    """优化作物组合\n    \n    参数:\n        crops: [{"name", "profit_per_ha", "water_per_ha"}, ...]\n        total_land: 总土地(ha)\n        total_water: 总水量(m³)\n        \n    返回:\n        各作物面积\n    """\n    optimizer = LinearOptimizer()\n    \n    for crop in crops:\n        optimizer.add_variable(crop["name"], 0, total_land)\n    \n    # 目标: 最大化利润\n    optimizer.set_objective(\n        {c["name"]: c["profit_per_ha"] for c in crops},\n        maximize=True\n    )\n    \n    # 约束: 总面积\n    optimizer.add_constraint({c["name"]: 1 for c in crops}, "<=", total_land)\n    \n    # 约束: 总水量\n    optimizer.add_constraint(\n        {c["name"]: c["water_per_ha"] for c in crops},\n        "<=",\n        total_water\n    )\n    \n    result = optimizer.solve()\n    return result.variables\n\n\nif __name__ == "__main__":\n    print("=" * 50)\n    print("线性规划优化演示")\n    print("=" * 50)\n    \n    crops = [\n        {"name": "wheat", "profit_per_ha": 500, "water_per_ha": 3000},\n        {"name": "maize", "profit_per_ha": 600, "water_per_ha": 5000},\n        {"name": "alfalfa", "profit_per_ha": 400, "water_per_ha": 2000},\n    ]\n    \n    solution = optimize_crop_mix(crops, total_land=100, total_water=300000)\n    \n    print("\\n优化种植方案:")\n    for crop, area in solution.items():\n        print(f"  {crop}: {area:.1f} ha")\n',
    "hetao_ag/opt/planning.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag.opt.planning - 农场规划\n\n综合农场规划和场景分析工具。\n\n作者: Hetao College\n版本: 1.0.0\n"""\n\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport numpy as np\n\n\n@dataclass\nclass FarmScenario:\n    """农场情景"""\n    name: str\n    crop_areas: Dict[str, float]\n    irrigation_mm: float\n    expected_yield: Dict[str, float]\n    total_profit: float\n    water_use_efficiency: float\n\n\nclass ScenarioEvaluator:\n    """场景评估器\n    \n    评估和比较不同农场管理方案。\n    """\n    \n    def __init__(\n        self,\n        crop_params: Dict[str, Dict],\n        total_land: float,\n        total_water: float\n    ):\n        self.crop_params = crop_params\n        self.total_land = total_land\n        self.total_water = total_water\n        self.scenarios: List[FarmScenario] = []\n    \n    def evaluate_scenario(\n        self,\n        name: str,\n        crop_areas: Dict[str, float],\n        irrigation_mm: float\n    ) -> FarmScenario:\n        """评估单个方案"""\n        yields = {}\n        profit = 0.0\n        total_water_used = 0.0\n        \n        for crop, area in crop_areas.items():\n            params = self.crop_params.get(crop, {})\n            \n            # 基础产量\n            base_yield = params.get("yield_kg_ha", 5000)\n            \n            # 水分响应\n            water_need = params.get("water_need_mm", 400)\n            water_factor = min(1.0, irrigation_mm / water_need)\n            \n            actual_yield = base_yield * water_factor * 0.9\n            yields[crop] = actual_yield\n            \n            # 利润\n            price = params.get("price_per_kg", 1.0)\n            cost = params.get("cost_per_ha", 1000)\n            profit += actual_yield * area * price - cost * area\n            \n            total_water_used += irrigation_mm * area * 10  # m³\n        \n        wue = sum(y * a for y, a in zip(yields.values(), crop_areas.values())) / total_water_used if total_water_used > 0 else 0\n        \n        scenario = FarmScenario(\n            name=name,\n            crop_areas=crop_areas,\n            irrigation_mm=irrigation_mm,\n            expected_yield=yields,\n            total_profit=profit,\n            water_use_efficiency=wue\n        )\n        \n        self.scenarios.append(scenario)\n        return scenario\n    \n    def compare_scenarios(self) -> Dict[str, FarmScenario]:\n        """比较所有方案"""\n        if not self.scenarios:\n            return {}\n        \n        best_profit = max(self.scenarios, key=lambda s: s.total_profit)\n        best_wue = max(self.scenarios, key=lambda s: s.water_use_efficiency)\n        \n        return {\n            "best_profit": best_profit,\n            "best_water_efficiency": best_wue\n        }\n    \n    def sensitivity_analysis(\n        self,\n        base_scenario: FarmScenario,\n        parameter: str,\n        variations: List[float]\n    ) -> List[FarmScenario]:\n        """敏感性分析"""\n        results = []\n        \n        for var in variations:\n            if parameter == "irrigation":\n                new_irrig = base_scenario.irrigation_mm * (1 + var)\n                scenario = self.evaluate_scenario(\n                    f"irrigation_{var:+.0%}",\n                    base_scenario.crop_areas,\n                    new_irrig\n                )\n            results.append(scenario)\n        \n        return results\n\n\ndef multi_objective_score(\n    profit: float,\n    water_use: float,\n    sustainability: float,\n    weights: Dict[str, float] = None\n) -> float:\n    """多目标评分\n    \n    参数:\n        profit: 利润指标(0-1归一化)\n        water_use: 水效指标(0-1)\n        sustainability: 可持续性指标(0-1)\n        weights: 权重\n        \n    返回:\n        综合得分\n    """\n    w = weights or {"profit": 0.4, "water": 0.35, "sustainability": 0.25}\n    \n    score = (profit * w["profit"] + \n             water_use * w["water"] + \n             sustainability * w["sustainability"])\n    \n    return score\n\n\nif __name__ == "__main__":\n    print("=" * 50)\n    print("农场规划演示")\n    print("=" * 50)\n    \n    crop_params = {\n        "wheat": {"yield_kg_ha": 6000, "water_need_mm": 400, "price_per_kg": 0.8, "cost_per_ha": 1200},\n        "maize": {"yield_kg_ha": 10000, "water_need_mm": 600, "price_per_kg": 0.6, "cost_per_ha": 1500},\n    }\n    \n    evaluator = ScenarioEvaluator(crop_params, total_land=100, total_water=500000)\n    \n    # 评估方案\n    s1 = evaluator.evaluate_scenario("全小麦", {"wheat": 100}, 450)\n    s2 = evaluator.evaluate_scenario("全玉米", {"maize": 100}, 650)\n    s3 = evaluator.evaluate_scenario("混种", {"wheat": 50, "maize": 50}, 500)\n    \n    print("\\n方案评估:")\n    for s in [s1, s2, s3]:\n        print(f"  {s.name}: 利润=¥{s.total_profit:,.0f}, WUE={s.water_use_efficiency:.2f}")\n    \n    best = evaluator.compare_scenarios()\n    print(f"\\n最佳利润方案: {best[\'best_profit\'].name}")\n    print(f"最佳水效方案: {best[\'best_water_efficiency\'].name}")\n',
    "hetao_ag/soil/__init__.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag.soil - 土壤模块\n\n土壤水分和盐分建模、IoT传感器校准。\n\n作者: Hetao College\n版本: 1.0.0\n"""\n\nfrom .moisture import (\n    SoilMoistureModel,\n    SoilLayer,\n    SoilType,\n    SOIL_PARAMETERS,\n    van_genuchten_theta,\n)\n\nfrom .salinity import (\n    SalinityModel,\n    SalinityState,\n    classify_soil_salinity,\n    classify_water_salinity,\n)\n\nfrom .sensors import (\n    SensorCalibrator,\n    CalibrationResult,\n    CalibrationMethod,\n    MoistureSensor,\n    capacitive_sensor_formula,\n)\n\n__all__ = [\n    # moisture\n    "SoilMoistureModel",\n    "SoilLayer",\n    "SoilType",\n    "SOIL_PARAMETERS",\n    "van_genuchten_theta",\n    # salinity\n    "SalinityModel",\n    "SalinityState",\n    "classify_soil_salinity",\n    "classify_water_salinity",\n    # sensors\n    "SensorCalibrator",\n    "CalibrationResult",\n    "CalibrationMethod",\n    "MoistureSensor",\n    "capacitive_sensor_formula",\n]\n',
    "hetao_ag/soil/moisture.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag.soil.moisture - 土壤水分模型\n\n提供土壤水分动态模拟，包括入渗、蒸发、渗透等过程。\n\n作者: Hetao College\n版本: 1.0.0\n"""\n\nimport numpy as np\nfrom dataclasses import dataclass, field\nfrom typing import Optional, List, Tuple\nfrom enum import Enum\n\n\nclass SoilType(Enum):\n    """土壤类型枚举"""\n    SAND = "sand"\n    LOAMY_SAND = "loamy_sand"\n    SANDY_LOAM = "sandy_loam"\n    LOAM = "loam"\n    SILT_LOAM = "silt_loam"\n    SILT = "silt"\n    SANDY_CLAY_LOAM = "sandy_clay_loam"\n    CLAY_LOAM = "clay_loam"\n    SILTY_CLAY_LOAM = "silty_clay_loam"\n    SANDY_CLAY = "sandy_clay"\n    SILTY_CLAY = "silty_clay"\n    CLAY = "clay"\n\n\n# 土壤水力特性参数(van Genuchten参数)\nSOIL_PARAMETERS = {\n    SoilType.SAND: {"theta_r": 0.045, "theta_s": 0.43, "alpha": 0.145, "n": 2.68, "Ks": 712.8},\n    SoilType.LOAMY_SAND: {"theta_r": 0.057, "theta_s": 0.41, "alpha": 0.124, "n": 2.28, "Ks": 350.2},\n    SoilType.SANDY_LOAM: {"theta_r": 0.065, "theta_s": 0.41, "alpha": 0.075, "n": 1.89, "Ks": 106.1},\n    SoilType.LOAM: {"theta_r": 0.078, "theta_s": 0.43, "alpha": 0.036, "n": 1.56, "Ks": 25.0},\n    SoilType.SILT_LOAM: {"theta_r": 0.067, "theta_s": 0.45, "alpha": 0.020, "n": 1.41, "Ks": 10.8},\n    SoilType.SILT: {"theta_r": 0.034, "theta_s": 0.46, "alpha": 0.016, "n": 1.37, "Ks": 6.0},\n    SoilType.SANDY_CLAY_LOAM: {"theta_r": 0.100, "theta_s": 0.39, "alpha": 0.059, "n": 1.48, "Ks": 31.4},\n    SoilType.CLAY_LOAM: {"theta_r": 0.095, "theta_s": 0.41, "alpha": 0.019, "n": 1.31, "Ks": 6.2},\n    SoilType.SILTY_CLAY_LOAM: {"theta_r": 0.089, "theta_s": 0.43, "alpha": 0.010, "n": 1.23, "Ks": 1.7},\n    SoilType.SANDY_CLAY: {"theta_r": 0.100, "theta_s": 0.38, "alpha": 0.027, "n": 1.23, "Ks": 2.9},\n    SoilType.SILTY_CLAY: {"theta_r": 0.070, "theta_s": 0.36, "alpha": 0.005, "n": 1.09, "Ks": 0.5},\n    SoilType.CLAY: {"theta_r": 0.068, "theta_s": 0.38, "alpha": 0.008, "n": 1.09, "Ks": 4.8},\n}\n\n\n@dataclass\nclass SoilLayer:\n    """土壤层数据类\n    \n    属性:\n        depth_m: 层厚度(m)\n        moisture: 体积含水量(m³/m³)\n        field_capacity: 田间持水量\n        wilting_point: 凋萎点\n        saturation: 饱和含水量\n        soil_type: 土壤类型\n    """\n    depth_m: float\n    moisture: float\n    field_capacity: float = 0.30\n    wilting_point: float = 0.12\n    saturation: float = 0.45\n    soil_type: SoilType = SoilType.LOAM\n    \n    def __post_init__(self):\n        params = SOIL_PARAMETERS.get(self.soil_type, {})\n        if params and self.saturation == 0.45:\n            self.saturation = params.get("theta_s", 0.45)\n            self.wilting_point = params.get("theta_r", 0.12) * 1.5\n    \n    @property\n    def available_water(self) -> float:\n        """可利用水分(相对于凋萎点)"""\n        return max(0, self.moisture - self.wilting_point)\n    \n    @property\n    def deficit_to_fc(self) -> float:\n        """到田间持水量的亏缺"""\n        return max(0, self.field_capacity - self.moisture)\n    \n    @property\n    def relative_saturation(self) -> float:\n        """相对饱和度(0-1)"""\n        return (self.moisture - self.wilting_point) / (self.saturation - self.wilting_point)\n\n\nclass SoilMoistureModel:\n    """土壤水分模型\n    \n    模拟土壤水分动态变化,包括降水入渗、蒸散发消耗、深层渗透等。\n    \n    示例:\n        >>> model = SoilMoistureModel(field_capacity=0.32, wilting_point=0.12)\n        >>> model.add_water(15.0)  # 添加15mm水\n        >>> model.remove_water(5.0)  # 移除5mm(蒸散发)\n        >>> print(model.moisture)\n    """\n    \n    def __init__(\n        self,\n        field_capacity: float = 0.30,\n        wilting_point: float = 0.12,\n        initial_moisture: float = 0.25,\n        root_depth_m: float = 0.3,\n        soil_type: SoilType = SoilType.LOAM\n    ):\n        """初始化土壤水分模型\n        \n        参数:\n            field_capacity: 田间持水量(体积含水量)\n            wilting_point: 凋萎点\n            initial_moisture: 初始含水量\n            root_depth_m: 根区深度(m)\n            soil_type: 土壤类型\n        """\n        self.field_capacity = field_capacity\n        self.wilting_point = wilting_point\n        self.moisture = initial_moisture\n        self.root_depth_m = root_depth_m\n        self.soil_type = soil_type\n        \n        params = SOIL_PARAMETERS.get(soil_type, {})\n        self.saturation = params.get("theta_s", 0.45)\n        self.Ks = params.get("Ks", 25.0)  # 饱和导水率 mm/day\n        \n        self.history: List[float] = [initial_moisture]\n        self.runoff_mm: float = 0.0\n        self.drainage_mm: float = 0.0\n    \n    def add_water(self, amount_mm: float) -> Tuple[float, float]:\n        """添加水分(降水/灌溉)\n        \n        参数:\n            amount_mm: 水量(mm)\n            \n        返回:\n            (实际入渗量mm, 地表径流mm)\n        """\n        # 转换mm水深到体积含水量变化\n        added_theta = amount_mm / (self.root_depth_m * 1000)\n        \n        new_moisture = self.moisture + added_theta\n        \n        # 超过饱和的部分变成径流\n        if new_moisture > self.saturation:\n            runoff_theta = new_moisture - self.saturation\n            runoff_mm = runoff_theta * self.root_depth_m * 1000\n            new_moisture = self.saturation\n        else:\n            runoff_mm = 0.0\n        \n        infiltration = amount_mm - runoff_mm\n        self.moisture = new_moisture\n        self.runoff_mm += runoff_mm\n        \n        return infiltration, runoff_mm\n    \n    def remove_water(self, amount_mm: float) -> float:\n        """移除水分(蒸散发)\n        \n        参数:\n            amount_mm: 移除量(mm)\n            \n        返回:\n            实际移除量(mm)\n        """\n        removed_theta = amount_mm / (self.root_depth_m * 1000)\n        \n        new_moisture = self.moisture - removed_theta\n        \n        # 不能低于凋萎点\n        if new_moisture < self.wilting_point:\n            actual_removed_theta = self.moisture - self.wilting_point\n            new_moisture = self.wilting_point\n        else:\n            actual_removed_theta = removed_theta\n        \n        self.moisture = new_moisture\n        return actual_removed_theta * self.root_depth_m * 1000\n    \n    def deep_percolation(self) -> float:\n        """计算深层渗透(超过田间持水量的水分)\n        \n        返回:\n            渗透量(mm)\n        """\n        if self.moisture > self.field_capacity:\n            excess_theta = self.moisture - self.field_capacity\n            # 简化模型：假设一天内过量水分下渗\n            drainage = excess_theta * self.root_depth_m * 1000\n            self.moisture = self.field_capacity\n            self.drainage_mm += drainage\n            return drainage\n        return 0.0\n    \n    def step_day(self, rain_mm: float = 0, irrigation_mm: float = 0, et_mm: float = 0) -> dict:\n        """模拟一天的水分变化\n        \n        参数:\n            rain_mm: 降水量\n            irrigation_mm: 灌溉量\n            et_mm: 蒸散发量\n            \n        返回:\n            当日水分收支详情\n        """\n        # 1. 入渗\n        total_input = rain_mm + irrigation_mm\n        infiltration, runoff = self.add_water(total_input)\n        \n        # 2. 蒸散发\n        actual_et = self.remove_water(et_mm)\n        \n        # 3. 深层渗透\n        drainage = self.deep_percolation()\n        \n        # 记录历史\n        self.history.append(self.moisture)\n        \n        return {\n            "moisture": self.moisture,\n            "infiltration_mm": infiltration,\n            "runoff_mm": runoff,\n            "et_mm": actual_et,\n            "drainage_mm": drainage\n        }\n    \n    @property\n    def stress_factor(self) -> float:\n        """水分胁迫因子(0-1, 1表示无胁迫)"""\n        if self.moisture >= self.field_capacity:\n            return 1.0\n        elif self.moisture <= self.wilting_point:\n            return 0.0\n        else:\n            return (self.moisture - self.wilting_point) / (self.field_capacity - self.wilting_point)\n    \n    @property\n    def irrigation_need_mm(self) -> float:\n        """需要灌溉量(补充到田间持水量)"""\n        deficit = self.field_capacity - self.moisture\n        return max(0, deficit * self.root_depth_m * 1000)\n    \n    def get_history_array(self) -> np.ndarray:\n        """获取含水量历史数组"""\n        return np.array(self.history)\n\n\ndef van_genuchten_theta(h: float, theta_r: float, theta_s: float, alpha: float, n: float) -> float:\n    """van Genuchten土壤水分特征曲线\n    \n    参数:\n        h: 压力水头(cm, 负值)\n        theta_r: 残余含水量\n        theta_s: 饱和含水量\n        alpha: 形状参数\n        n: 形状参数\n        \n    返回:\n        体积含水量\n    """\n    if h >= 0:\n        return theta_s\n    \n    m = 1 - 1/n\n    return theta_r + (theta_s - theta_r) / (1 + (alpha * abs(h)) ** n) ** m\n\n\nif __name__ == "__main__":\n    print("=" * 50)\n    print("土壤水分模型演示")\n    print("=" * 50)\n    \n    model = SoilMoistureModel(\n        field_capacity=0.32,\n        wilting_point=0.12,\n        initial_moisture=0.25,\n        root_depth_m=0.3,\n        soil_type=SoilType.LOAM\n    )\n    \n    print(f"\\n初始含水量: {model.moisture:.3f}")\n    print(f"胁迫因子: {model.stress_factor:.3f}")\n    \n    # 模拟5天\n    weather = [\n        {"rain": 10, "et": 4},\n        {"rain": 0, "et": 5},\n        {"rain": 0, "et": 5},\n        {"rain": 20, "et": 3},\n        {"rain": 0, "et": 6},\n    ]\n    \n    print("\\n逐日模拟:")\n    for i, w in enumerate(weather, 1):\n        result = model.step_day(rain_mm=w["rain"], et_mm=w["et"])\n        print(f"第{i}天: 含水量={result[\'moisture\']:.3f}, ET={result[\'et_mm\']:.1f}mm")\n    \n    print(f"\\n最终含水量: {model.moisture:.3f}")\n    print(f"需灌溉量: {model.irrigation_need_mm:.1f} mm")\n',
    "hetao_ag/soil/salinity.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag.soil.salinity - 土壤盐分模型\n\n土壤盐分动态模拟，用于盐碱地管理和灌溉决策。\n\n作者: Hetao College\n版本: 1.0.0\n"""\n\nimport numpy as np\nfrom dataclasses import dataclass\nfrom typing import Optional, List\n\n\n@dataclass\nclass SalinityState:\n    """盐分状态\n    \n    属性:\n        ECe: 饱和泥浆提取液电导率(dS/m)\n        salt_mass_kg_ha: 盐分总量(kg/ha)\n        leaching_fraction: 淋洗系数\n    """\n    ECe: float\n    salt_mass_kg_ha: float = 0.0\n    leaching_fraction: float = 0.0\n\n\nclass SalinityModel:\n    """土壤盐分模型\n    \n    基于质量平衡原理模拟土壤盐分累积和淋洗过程。\n    符合FAO灌溉排水指南标准。\n    \n    示例:\n        >>> model = SalinityModel(initial_ECe=2.0)\n        >>> model.irrigate(100, ec_water=1.5)  # 灌溉100mm, 水EC=1.5 dS/m\n        >>> print(f"土壤EC: {model.ECe:.2f} dS/m")\n    """\n    \n    # EC到盐浓度的近似转换: TDS (mg/L) ≈ EC (dS/m) × 640\n    EC_TO_TDS_FACTOR = 640\n    \n    def __init__(\n        self,\n        initial_ECe: float = 2.0,\n        root_depth_m: float = 0.3,\n        soil_water_content: float = 0.30,\n        bulk_density: float = 1.4\n    ):\n        """初始化盐分模型\n        \n        参数:\n            initial_ECe: 初始土壤EC (dS/m)\n            root_depth_m: 根区深度(m)\n            soil_water_content: 土壤含水量\n            bulk_density: 土壤容重(g/cm³)\n        """\n        self.ECe = initial_ECe\n        self.root_depth_m = root_depth_m\n        self.soil_water_content = soil_water_content\n        self.bulk_density = bulk_density\n        \n        # 计算初始盐量\n        self.salt_mass = self._ec_to_salt_mass(initial_ECe)\n        \n        self.history: List[float] = [initial_ECe]\n    \n    def _ec_to_salt_mass(self, ec: float) -> float:\n        """将EC转换为盐质量(kg/ha)"""\n        # 土壤水体积 = 深度 × 含水量 × 面积(1ha = 10000m²)\n        water_volume_L = self.root_depth_m * self.soil_water_content * 10000 * 1000\n        # 盐浓度(mg/L)\n        tds_mg_L = ec * self.EC_TO_TDS_FACTOR\n        # 盐质量(kg)\n        salt_kg = tds_mg_L * water_volume_L / 1e6\n        return salt_kg\n    \n    def _salt_mass_to_ec(self, salt_kg: float) -> float:\n        """将盐质量转换为EC"""\n        water_volume_L = self.root_depth_m * self.soil_water_content * 10000 * 1000\n        if water_volume_L <= 0:\n            return 0.0\n        tds_mg_L = salt_kg * 1e6 / water_volume_L\n        return tds_mg_L / self.EC_TO_TDS_FACTOR\n    \n    def irrigate(self, amount_mm: float, ec_water: float) -> dict:\n        """灌溉过程\n        \n        参数:\n            amount_mm: 灌溉量(mm)\n            ec_water: 灌溉水EC (dS/m)\n            \n        返回:\n            盐分收支详情\n        """\n        # 灌溉水带入的盐量\n        water_volume_L = amount_mm * 10000  # L/ha\n        salt_input_kg = ec_water * self.EC_TO_TDS_FACTOR * water_volume_L / 1e6\n        \n        self.salt_mass += salt_input_kg\n        self.ECe = self._salt_mass_to_ec(self.salt_mass)\n        self.history.append(self.ECe)\n        \n        return {\n            "salt_input_kg_ha": salt_input_kg,\n            "ECe": self.ECe\n        }\n    \n    def leach(self, drainage_mm: float) -> dict:\n        """淋洗过程\n        \n        参数:\n            drainage_mm: 排水量(mm)\n            \n        返回:\n            淋洗详情\n        """\n        # 淋洗系数 = 排水量 / 根区水量\n        root_water_mm = self.root_depth_m * self.soil_water_content * 1000\n        \n        if root_water_mm > 0:\n            leaching_fraction = min(1.0, drainage_mm / root_water_mm)\n        else:\n            leaching_fraction = 0.0\n        \n        # 盐分随水淋洗\n        salt_removed = self.salt_mass * leaching_fraction * 0.8  # 假设80%效率\n        self.salt_mass -= salt_removed\n        self.ECe = self._salt_mass_to_ec(self.salt_mass)\n        self.history.append(self.ECe)\n        \n        return {\n            "salt_removed_kg_ha": salt_removed,\n            "leaching_fraction": leaching_fraction,\n            "ECe": self.ECe\n        }\n    \n    def leaching_requirement(self, ec_irrigation: float, ec_threshold: float) -> float:\n        """计算淋洗需水量\n        \n        根据FAO方法计算维持土壤盐分在阈值以下所需的淋洗系数。\n        \n        参数:\n            ec_irrigation: 灌溉水EC (dS/m)\n            ec_threshold: 目标土壤EC阈值 (dS/m)\n            \n        返回:\n            淋洗需求系数(0-1)\n        """\n        if ec_threshold <= 0:\n            return 1.0\n        \n        # FAO简化公式: LR = ECiw / (5 * ECe - ECiw)\n        denominator = 5 * ec_threshold - ec_irrigation\n        if denominator <= 0:\n            return 1.0\n        \n        lr = ec_irrigation / denominator\n        return min(1.0, max(0.0, lr))\n    \n    def step_day(self, irrigation_mm: float = 0, ec_irrigation: float = 1.0,\n                 drainage_mm: float = 0) -> dict:\n        """模拟一天的盐分变化\n        \n        参数:\n            irrigation_mm: 灌溉量\n            ec_irrigation: 灌溉水EC\n            drainage_mm: 排水量\n            \n        返回:\n            当日盐分收支\n        """\n        result = {"ECe_start": self.ECe}\n        \n        if irrigation_mm > 0:\n            irr_result = self.irrigate(irrigation_mm, ec_irrigation)\n            result["salt_input_kg_ha"] = irr_result["salt_input_kg_ha"]\n        \n        if drainage_mm > 0:\n            leach_result = self.leach(drainage_mm)\n            result["salt_removed_kg_ha"] = leach_result["salt_removed_kg_ha"]\n        \n        result["ECe_end"] = self.ECe\n        return result\n    \n    def get_history_array(self) -> np.ndarray:\n        """获取EC历史数组"""\n        return np.array(self.history)\n\n\ndef classify_soil_salinity(ECe: float) -> str:\n    """土壤盐分分级\n    \n    参数:\n        ECe: 土壤电导率(dS/m)\n        \n    返回:\n        盐分等级描述\n    """\n    if ECe < 2:\n        return "非盐渍化(适合大多数作物)"\n    elif ECe < 4:\n        return "轻度盐渍化(敏感作物受影响)"\n    elif ECe < 8:\n        return "中度盐渍化(多数作物减产)"\n    elif ECe < 16:\n        return "重度盐渍化(仅耐盐作物可种植)"\n    else:\n        return "极重度盐渍化(不适宜种植)"\n\n\ndef classify_water_salinity(EC: float) -> str:\n    """灌溉水盐分分级\n    \n    参数:\n        EC: 水电导率(dS/m)\n        \n    返回:\n        水质等级\n    """\n    if EC < 0.7:\n        return "优良(无限制)"\n    elif EC < 3.0:\n        return "良好(轻度限制)"\n    else:\n        return "较差(重度限制)"\n\n\nif __name__ == "__main__":\n    print("=" * 50)\n    print("土壤盐分模型演示")\n    print("=" * 50)\n    \n    model = SalinityModel(initial_ECe=3.0, root_depth_m=0.3)\n    \n    print(f"\\n初始EC: {model.ECe:.2f} dS/m")\n    print(f"等级: {classify_soil_salinity(model.ECe)}")\n    \n    # 灌溉\n    result = model.irrigate(100, ec_water=2.0)\n    print(f"\\n灌溉后EC: {model.ECe:.2f} dS/m")\n    \n    # 淋洗\n    result = model.leach(50)\n    print(f"淋洗后EC: {model.ECe:.2f} dS/m")\n    \n    # 计算淋洗需求\n    lr = model.leaching_requirement(ec_irrigation=1.5, ec_threshold=4.0)\n    print(f"\\n淋洗需求系数: {lr:.3f}")\n',
    "hetao_ag/soil/sensors.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag.soil.sensors - 土壤传感器校准\n\nIoT土壤传感器的校准和数据处理工具。\n\n作者: Hetao College\n版本: 1.0.0\n"""\n\nimport numpy as np\nfrom dataclasses import dataclass\nfrom typing import Tuple, Optional, List, Callable\nfrom enum import Enum\n\n\nclass CalibrationMethod(Enum):\n    """校准方法枚举"""\n    LINEAR = "linear"\n    POLYNOMIAL = "polynomial"\n    POWER = "power"\n\n\n@dataclass\nclass CalibrationResult:\n    """校准结果\n    \n    属性:\n        method: 校准方法\n        coefficients: 系数\n        r_squared: R²值\n        rmse: 均方根误差\n    """\n    method: CalibrationMethod\n    coefficients: Tuple\n    r_squared: float\n    rmse: float\n    \n    def apply(self, raw_value: float) -> float:\n        """应用校准"""\n        if self.method == CalibrationMethod.LINEAR:\n            slope, intercept = self.coefficients\n            return slope * raw_value + intercept\n        elif self.method == CalibrationMethod.POLYNOMIAL:\n            return np.polyval(self.coefficients, raw_value)\n        elif self.method == CalibrationMethod.POWER:\n            a, b = self.coefficients\n            return a * (raw_value ** b)\n        return raw_value\n    \n    def __str__(self) -> str:\n        return f"{self.method.value}校准: R²={self.r_squared:.4f}, RMSE={self.rmse:.4f}"\n\n\nclass SensorCalibrator:\n    """传感器校准器\n    \n    支持多种校准方法，用于校准低成本土壤传感器。\n    \n    示例:\n        >>> calibrator = SensorCalibrator()\n        >>> raw = [300, 450, 600, 750]\n        >>> true = [0.10, 0.20, 0.30, 0.40]\n        >>> result = calibrator.linear_calibration(raw, true)\n        >>> corrected = result.apply(500)\n    """\n    \n    def __init__(self):\n        self.calibrations: dict = {}\n    \n    def linear_calibration(\n        self,\n        raw_readings: np.ndarray,\n        ground_truth: np.ndarray\n    ) -> CalibrationResult:\n        """线性校准\n        \n        参数:\n            raw_readings: 原始传感器读数\n            ground_truth: 真实值\n            \n        返回:\n            CalibrationResult对象\n        """\n        raw = np.array(raw_readings, dtype=float)\n        true = np.array(ground_truth, dtype=float)\n        \n        # 最小二乘线性拟合\n        A = np.vstack([raw, np.ones(len(raw))]).T\n        slope, intercept = np.linalg.lstsq(A, true, rcond=None)[0]\n        \n        # 计算拟合优度\n        predicted = slope * raw + intercept\n        r_squared = self._r_squared(true, predicted)\n        rmse = self._rmse(true, predicted)\n        \n        return CalibrationResult(\n            method=CalibrationMethod.LINEAR,\n            coefficients=(slope, intercept),\n            r_squared=r_squared,\n            rmse=rmse\n        )\n    \n    def polynomial_calibration(\n        self,\n        raw_readings: np.ndarray,\n        ground_truth: np.ndarray,\n        degree: int = 2\n    ) -> CalibrationResult:\n        """多项式校准\n        \n        参数:\n            raw_readings: 原始读数\n            ground_truth: 真实值\n            degree: 多项式次数\n            \n        返回:\n            CalibrationResult对象\n        """\n        raw = np.array(raw_readings, dtype=float)\n        true = np.array(ground_truth, dtype=float)\n        \n        coeffs = np.polyfit(raw, true, degree)\n        predicted = np.polyval(coeffs, raw)\n        \n        return CalibrationResult(\n            method=CalibrationMethod.POLYNOMIAL,\n            coefficients=tuple(coeffs),\n            r_squared=self._r_squared(true, predicted),\n            rmse=self._rmse(true, predicted)\n        )\n    \n    def auto_calibrate(\n        self,\n        raw_readings: np.ndarray,\n        ground_truth: np.ndarray\n    ) -> CalibrationResult:\n        """自动选择最佳校准方法\n        \n        参数:\n            raw_readings: 原始读数\n            ground_truth: 真实值\n            \n        返回:\n            最佳校准结果\n        """\n        results = [\n            self.linear_calibration(raw_readings, ground_truth),\n            self.polynomial_calibration(raw_readings, ground_truth, degree=2),\n        ]\n        \n        # 选择R²最高的\n        best = max(results, key=lambda r: r.r_squared)\n        return best\n    \n    @staticmethod\n    def _r_squared(observed: np.ndarray, predicted: np.ndarray) -> float:\n        """计算R²"""\n        ss_res = np.sum((observed - predicted) ** 2)\n        ss_tot = np.sum((observed - np.mean(observed)) ** 2)\n        if ss_tot == 0:\n            return 1.0 if ss_res == 0 else 0.0\n        return 1.0 - ss_res / ss_tot\n    \n    @staticmethod\n    def _rmse(observed: np.ndarray, predicted: np.ndarray) -> float:\n        """计算RMSE"""\n        return float(np.sqrt(np.mean((observed - predicted) ** 2)))\n\n\nclass MoistureSensor:\n    """土壤水分传感器接口\n    \n    示例:\n        >>> sensor = MoistureSensor(sensor_id="SM01", calibration=result)\n        >>> moisture = sensor.read_calibrated(raw_value=450)\n    """\n    \n    def __init__(\n        self,\n        sensor_id: str,\n        calibration: Optional[CalibrationResult] = None,\n        min_raw: float = 0,\n        max_raw: float = 1023\n    ):\n        self.sensor_id = sensor_id\n        self.calibration = calibration\n        self.min_raw = min_raw\n        self.max_raw = max_raw\n        self.readings: List[Tuple[float, float]] = []  # (timestamp, value)\n    \n    def read_calibrated(self, raw_value: float) -> float:\n        """读取校准后的值\n        \n        参数:\n            raw_value: 原始读数\n            \n        返回:\n            校准后的体积含水量\n        """\n        if self.calibration:\n            return self.calibration.apply(raw_value)\n        else:\n            # 默认线性映射到0-1范围\n            return (raw_value - self.min_raw) / (self.max_raw - self.min_raw)\n    \n    def add_reading(self, timestamp: float, raw_value: float):\n        """添加读数记录"""\n        calibrated = self.read_calibrated(raw_value)\n        self.readings.append((timestamp, calibrated))\n    \n    def get_average(self, n_last: int = 10) -> float:\n        """获取最近n次读数的平均值"""\n        if not self.readings:\n            return 0.0\n        recent = self.readings[-n_last:]\n        return np.mean([r[1] for r in recent])\n\n\ndef capacitive_sensor_formula(raw: float, dry_value: float = 520, wet_value: float = 260) -> float:\n    """电容式土壤水分传感器通用公式\n    \n    适用于常见低成本电容式传感器(如DFRobot SEN0193)。\n    \n    参数:\n        raw: 原始ADC读数\n        dry_value: 干燥空气中的读数\n        wet_value: 纯水中的读数\n        \n    返回:\n        相对湿度(0-100%)\n    """\n    if dry_value == wet_value:\n        return 50.0\n    \n    moisture_percent = 100 * (dry_value - raw) / (dry_value - wet_value)\n    return max(0, min(100, moisture_percent))\n\n\nif __name__ == "__main__":\n    print("=" * 50)\n    print("传感器校准演示")\n    print("=" * 50)\n    \n    # 模拟校准数据\n    raw_vals = np.array([300, 400, 500, 600, 700])\n    true_vwc = np.array([0.10, 0.18, 0.28, 0.35, 0.42])\n    \n    calibrator = SensorCalibrator()\n    \n    # 线性校准\n    linear_result = calibrator.linear_calibration(raw_vals, true_vwc)\n    print(f"\\n{linear_result}")\n    \n    # 多项式校准\n    poly_result = calibrator.polynomial_calibration(raw_vals, true_vwc, degree=2)\n    print(f"{poly_result}")\n    \n    # 自动校准\n    best = calibrator.auto_calibrate(raw_vals, true_vwc)\n    print(f"\\n最佳方法: {best.method.value}")\n    \n    # 应用校准\n    test_raw = 450\n    calibrated = best.apply(test_raw)\n    print(f"\\n原始读数 {test_raw} -> 校准值 {calibrated:.3f}")\n',
    "hetao_ag/space/__init__.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag.space - 遥感模块\n\n遥感影像处理、光谱指数计算和物候分类。\n\n作者: Hetao College\n版本: 1.0.0\n"""\n\nfrom .indices import (\n    compute_ndvi,\n    compute_savi,\n    compute_lswi,\n    compute_evi,\n    compute_ndwi,\n    classify_vegetation_health,\n)\n\nfrom .imagery import (\n    RasterImage,\n    GeoMetadata,\n    CloudMask,\n)\n\nfrom .classification import (\n    PhenologyClassifier,\n    PhenologyFeatures,\n    temporal_smoothing,\n)\n\n__all__ = [\n    # indices\n    "compute_ndvi",\n    "compute_savi",\n    "compute_lswi",\n    "compute_evi",\n    "compute_ndwi",\n    "classify_vegetation_health",\n    # imagery\n    "RasterImage",\n    "GeoMetadata",\n    "CloudMask",\n    # classification\n    "PhenologyClassifier",\n    "PhenologyFeatures",\n    "temporal_smoothing",\n]\n',
    "hetao_ag/space/classification.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag.space.classification - 物候分类\n\n遥感时序物候分类和作物识别。\n\n作者: Hetao College\n版本: 1.0.0\n"""\n\nimport numpy as np\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\n\n\n@dataclass\nclass PhenologyFeatures:\n    """物候特征"""\n    peak_value: float\n    peak_time: int\n    start_of_season: int\n    end_of_season: int\n    amplitude: float\n\n\nclass PhenologyClassifier:\n    """物候分类器\n    \n    基于NDVI时序数据进行作物分类。\n    \n    示例:\n        >>> classifier = PhenologyClassifier(ndvi_series, dates)\n        >>> crop_map = classifier.classify_crops()\n    """\n    \n    def __init__(self, time_series: np.ndarray, dates: Optional[List] = None):\n        """初始化分类器\n        \n        参数:\n            time_series: NDVI时序数据 (time, height, width)\n            dates: 日期列表\n        """\n        self.data = time_series\n        self.dates = dates or list(range(time_series.shape[0]))\n        \n        self.peak = np.max(time_series, axis=0)\n        self.peak_time = np.argmax(time_series, axis=0)\n    \n    def extract_features(self, row: int, col: int) -> PhenologyFeatures:\n        """提取像素物候特征\n        \n        参数:\n            row, col: 像素坐标\n            \n        返回:\n            物候特征\n        """\n        series = self.data[:, row, col]\n        peak_val = np.max(series)\n        peak_idx = np.argmax(series)\n        \n        # 简化的季节起止检测\n        threshold = peak_val * 0.3\n        above_threshold = series > threshold\n        start = np.argmax(above_threshold) if np.any(above_threshold) else 0\n        end = len(series) - np.argmax(above_threshold[::-1]) if np.any(above_threshold) else len(series)\n        \n        return PhenologyFeatures(\n            peak_value=float(peak_val),\n            peak_time=int(peak_idx),\n            start_of_season=int(start),\n            end_of_season=int(end),\n            amplitude=float(peak_val - np.min(series))\n        )\n    \n    def classify_crops(self, n_classes: int = 3) -> np.ndarray:\n        """作物分类\n        \n        基于峰值时间和峰值大小进行简单分类。\n        \n        参数:\n            n_classes: 类别数\n            \n        返回:\n            分类结果\n        """\n        classes = np.zeros_like(self.peak_time)\n        n_times = self.data.shape[0]\n        early_threshold = n_times // 3\n        late_threshold = 2 * n_times // 3\n        \n        # 规则分类\n        # 类别1: 早峰(如冬小麦)\n        classes[(self.peak_time < early_threshold) & (self.peak > 0.5)] = 1\n        \n        # 类别2: 晚峰(如玉米)\n        classes[(self.peak_time >= late_threshold) & (self.peak > 0.5)] = 2\n        \n        # 类别3: 中峰\n        classes[(self.peak_time >= early_threshold) & (self.peak_time < late_threshold) & (self.peak > 0.5)] = 3\n        \n        # 低NDVI区域为非作物(0)\n        return classes\n    \n    def get_phenology_map(self) -> Dict[str, np.ndarray]:\n        """生成物候参数图"""\n        return {\n            "peak_ndvi": self.peak,\n            "peak_time": self.peak_time,\n            "season_length": self._compute_season_length(),\n        }\n    \n    def _compute_season_length(self, threshold_ratio: float = 0.3) -> np.ndarray:\n        """计算生长季长度"""\n        threshold = self.peak * threshold_ratio\n        \n        season_length = np.zeros(self.peak.shape, dtype=int)\n        \n        for i in range(self.data.shape[1]):\n            for j in range(self.data.shape[2]):\n                series = self.data[:, i, j]\n                thresh = threshold[i, j]\n                above = series > thresh\n                if np.any(above):\n                    start = np.argmax(above)\n                    end = len(series) - np.argmax(above[::-1])\n                    season_length[i, j] = end - start\n        \n        return season_length\n\n\ndef temporal_smoothing(time_series: np.ndarray, window: int = 3) -> np.ndarray:\n    """时序平滑\n    \n    参数:\n        time_series: 输入时序 (time, ...)\n        window: 平滑窗口\n        \n    返回:\n        平滑后的时序\n    """\n    if window <= 1:\n        return time_series\n    \n    kernel = np.ones(window) / window\n    shape = time_series.shape\n    \n    if len(shape) == 1:\n        return np.convolve(time_series, kernel, mode=\'same\')\n    \n    result = np.zeros_like(time_series, dtype=float)\n    for i in range(shape[1]):\n        for j in range(shape[2]):\n            result[:, i, j] = np.convolve(time_series[:, i, j], kernel, mode=\'same\')\n    \n    return result\n\n\nif __name__ == "__main__":\n    print("=" * 50)\n    print("物候分类演示")\n    print("=" * 50)\n    \n    # 模拟NDVI时序数据\n    np.random.seed(42)\n    times, h, w = 12, 50, 50\n    \n    # 创建模拟的季节性NDVI\n    t = np.linspace(0, 2*np.pi, times)\n    base_curve = 0.3 + 0.4 * np.sin(t)\n    \n    ndvi_series = np.zeros((times, h, w))\n    for i in range(h):\n        for j in range(w):\n            shift = np.random.randint(-2, 3)\n            noise = np.random.randn(times) * 0.05\n            ndvi_series[:, i, j] = np.roll(base_curve, shift) + noise\n    \n    ndvi_series = np.clip(ndvi_series, 0, 1)\n    \n    classifier = PhenologyClassifier(ndvi_series)\n    \n    # 分类\n    crop_map = classifier.classify_crops()\n    \n    print(f"\\n分类结果统计:")\n    for c in range(4):\n        count = np.sum(crop_map == c)\n        print(f"  类别{c}: {count}像素 ({count/crop_map.size*100:.1f}%)")\n    \n    # 物候特征\n    features = classifier.extract_features(25, 25)\n    print(f"\\n像素(25,25)物候特征:")\n    print(f"  峰值NDVI: {features.peak_value:.3f}")\n    print(f"  峰值时间: 第{features.peak_time}期")\n',
    "hetao_ag/space/imagery.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag.space.imagery - 影像处理\n\n遥感影像加载和处理。\n\n作者: Hetao College\n版本: 1.0.0\n"""\n\nfrom dataclasses import dataclass\nfrom typing import Optional, Dict, Tuple\nimport numpy as np\nfrom pathlib import Path\n\n\n@dataclass\nclass GeoMetadata:\n    """地理空间元数据"""\n    crs: str = "EPSG:4326"\n    transform: Optional[Tuple] = None\n    bounds: Optional[Tuple] = None\n    resolution: Optional[float] = None\n\n\nclass RasterImage:\n    """栅格影像类\n    \n    示例:\n        >>> img = RasterImage.from_file("sentinel2.tif")\n        >>> red = img.get_band("red")\n        >>> nir = img.get_band("nir")\n    """\n    \n    # Sentinel-2波段映射\n    SENTINEL2_BANDS = {\n        "blue": 1, "green": 2, "red": 3, "nir": 7, "swir1": 11, "swir2": 12\n    }\n    \n    def __init__(\n        self,\n        data: np.ndarray,\n        band_names: Optional[Dict[str, int]] = None,\n        metadata: Optional[GeoMetadata] = None\n    ):\n        """初始化栅格影像\n        \n        参数:\n            data: 影像数据 (bands, height, width)\n            band_names: 波段名称映射\n            metadata: 地理空间元数据\n        """\n        self.data = data\n        self.band_names = band_names or {}\n        self.metadata = metadata or GeoMetadata()\n    \n    @classmethod\n    def from_file(cls, path: str) -> \'RasterImage\':\n        """从文件加载影像"""\n        try:\n            import rasterio\n            with rasterio.open(path) as src:\n                data = src.read()\n                metadata = GeoMetadata(\n                    crs=str(src.crs),\n                    transform=src.transform,\n                    bounds=src.bounds,\n                    resolution=src.res[0]\n                )\n            return cls(data, metadata=metadata)\n        except ImportError:\n            # 返回模拟数据\n            print("警告: rasterio未安装,使用模拟数据")\n            data = np.random.randint(0, 255, (4, 100, 100), dtype=np.uint8)\n            return cls(data)\n    \n    def get_band(self, name_or_index) -> np.ndarray:\n        """获取指定波段\n        \n        参数:\n            name_or_index: 波段名称或索引\n            \n        返回:\n            波段数据\n        """\n        if isinstance(name_or_index, str):\n            idx = self.band_names.get(name_or_index)\n            if idx is None:\n                idx = self.SENTINEL2_BANDS.get(name_or_index.lower(), 0)\n            if idx >= 1:\n                idx -= 1  # 转为0索引\n        else:\n            idx = name_or_index\n        \n        if idx < self.data.shape[0]:\n            return self.data[idx]\n        return self.data[0]\n    \n    @property\n    def shape(self) -> Tuple[int, int, int]:\n        """影像形状 (bands, height, width)"""\n        return self.data.shape\n    \n    @property\n    def n_bands(self) -> int:\n        """波段数量"""\n        return self.data.shape[0]\n    \n    def subset(self, row_slice: slice, col_slice: slice) -> \'RasterImage\':\n        """裁剪影像"""\n        new_data = self.data[:, row_slice, col_slice]\n        return RasterImage(new_data, self.band_names, self.metadata)\n    \n    def apply_mask(self, mask: np.ndarray) -> \'RasterImage\':\n        """应用掩膜"""\n        masked_data = self.data.copy()\n        for i in range(self.n_bands):\n            masked_data[i] = np.where(mask, self.data[i], np.nan)\n        return RasterImage(masked_data, self.band_names, self.metadata)\n\n\nclass CloudMask:\n    """云掩膜生成器"""\n    \n    def __init__(self, threshold: float = 0.3):\n        self.threshold = threshold\n    \n    def from_qa_band(self, qa_band: np.ndarray) -> np.ndarray:\n        """从QA波段生成云掩膜"""\n        # 简化实现:假设高值为云\n        cloud_mask = qa_band > (np.max(qa_band) * self.threshold)\n        return ~cloud_mask  # 返回有效像素掩膜\n    \n    def simple_detection(self, blue: np.ndarray, nir: np.ndarray) -> np.ndarray:\n        """简单云检测"""\n        # 云通常在蓝光和近红外都很亮\n        bright = (blue > np.percentile(blue, 90)) & (nir > np.percentile(nir, 90))\n        return ~bright\n\n\nif __name__ == "__main__":\n    print("=" * 50)\n    print("影像处理演示")\n    print("=" * 50)\n    \n    # 创建模拟影像\n    data = np.random.randint(0, 10000, (4, 100, 100), dtype=np.uint16)\n    img = RasterImage(data, {"blue": 0, "green": 1, "red": 2, "nir": 3})\n    \n    print(f"\\n影像形状: {img.shape}")\n    print(f"波段数: {img.n_bands}")\n    \n    red = img.get_band("red")\n    nir = img.get_band("nir")\n    print(f"红光波段均值: {red.mean():.1f}")\n    print(f"近红外波段均值: {nir.mean():.1f}")\n',
    "hetao_ag/space/indices.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag.space.indices - 光谱指数计算\n\nNDVI、SAVI、LSWI等植被指数计算。\n\n作者: Hetao College\n版本: 1.0.0\n"""\n\nimport numpy as np\nfrom typing import Optional\n\n\ndef compute_ndvi(red: np.ndarray, nir: np.ndarray) -> np.ndarray:\n    """计算NDVI(归一化差值植被指数)\n    \n    NDVI = (NIR - Red) / (NIR + Red)\n    \n    参数:\n        red: 红光波段\n        nir: 近红外波段\n        \n    返回:\n        NDVI数组(-1到1)\n    """\n    red = red.astype(np.float32)\n    nir = nir.astype(np.float32)\n    \n    numerator = nir - red\n    denominator = nir + red\n    \n    ndvi = np.where(denominator == 0, 0, numerator / denominator)\n    return np.clip(ndvi, -1, 1)\n\n\ndef compute_savi(red: np.ndarray, nir: np.ndarray, L: float = 0.5) -> np.ndarray:\n    """计算SAVI(土壤调节植被指数)\n    \n    SAVI = ((NIR - Red) / (NIR + Red + L)) * (1 + L)\n    \n    参数:\n        red: 红光波段\n        nir: 近红外波段\n        L: 土壤调节因子(0-1, 0.5适用于中等植被覆盖)\n        \n    返回:\n        SAVI数组\n    """\n    red = red.astype(np.float32)\n    nir = nir.astype(np.float32)\n    \n    numerator = nir - red\n    denominator = nir + red + L\n    \n    savi = np.where(denominator == 0, 0, numerator / denominator * (1 + L))\n    return savi\n\n\ndef compute_lswi(nir: np.ndarray, swir: np.ndarray) -> np.ndarray:\n    """计算LSWI(地表水指数)\n    \n    LSWI = (NIR - SWIR) / (NIR + SWIR)\n    \n    参数:\n        nir: 近红外波段\n        swir: 短波红外波段\n        \n    返回:\n        LSWI数组(-1到1)\n    """\n    nir = nir.astype(np.float32)\n    swir = swir.astype(np.float32)\n    \n    numerator = nir - swir\n    denominator = nir + swir\n    \n    lswi = np.where(denominator == 0, 0, numerator / denominator)\n    return np.clip(lswi, -1, 1)\n\n\ndef compute_evi(blue: np.ndarray, red: np.ndarray, nir: np.ndarray,\n                G: float = 2.5, C1: float = 6.0, C2: float = 7.5, L: float = 1.0) -> np.ndarray:\n    """计算EVI(增强型植被指数)\n    \n    EVI = G * (NIR - Red) / (NIR + C1*Red - C2*Blue + L)\n    \n    参数:\n        blue, red, nir: 波段数据\n        G, C1, C2, L: EVI参数\n        \n    返回:\n        EVI数组\n    """\n    blue = blue.astype(np.float32)\n    red = red.astype(np.float32)\n    nir = nir.astype(np.float32)\n    \n    numerator = G * (nir - red)\n    denominator = nir + C1 * red - C2 * blue + L\n    \n    evi = np.where(denominator == 0, 0, numerator / denominator)\n    return np.clip(evi, -1, 1)\n\n\ndef compute_ndwi(green: np.ndarray, nir: np.ndarray) -> np.ndarray:\n    """计算NDWI(归一化差值水体指数)\n    \n    NDWI = (Green - NIR) / (Green + NIR)\n    \n    参数:\n        green: 绿光波段\n        nir: 近红外波段\n        \n    返回:\n        NDWI数组\n    """\n    green = green.astype(np.float32)\n    nir = nir.astype(np.float32)\n    \n    numerator = green - nir\n    denominator = green + nir\n    \n    ndwi = np.where(denominator == 0, 0, numerator / denominator)\n    return np.clip(ndwi, -1, 1)\n\n\ndef classify_vegetation_health(ndvi: float) -> str:\n    """根据NDVI分类植被健康状态\n    \n    参数:\n        ndvi: NDVI值\n        \n    返回:\n        健康状态描述\n    """\n    if ndvi < 0:\n        return "水体/裸土"\n    elif ndvi < 0.2:\n        return "稀疏或无植被"\n    elif ndvi < 0.4:\n        return "轻度植被"\n    elif ndvi < 0.6:\n        return "中等植被"\n    elif ndvi < 0.8:\n        return "茂密植被"\n    else:\n        return "非常茂密植被"\n\n\nif __name__ == "__main__":\n    print("=" * 50)\n    print("光谱指数计算演示")\n    print("=" * 50)\n    \n    # 模拟波段数据\n    red = np.array([[120, 130], [110, 90]], dtype=np.uint16)\n    nir = np.array([[200, 210], [180, 160]], dtype=np.uint16)\n    \n    ndvi = compute_ndvi(red, nir)\n    print(f"\\nNDVI:\\n{ndvi}")\n    \n    savi = compute_savi(red, nir, L=0.5)\n    print(f"\\nSAVI (L=0.5):\\n{savi}")\n    \n    print(f"\\n植被状态: {classify_vegetation_health(0.65)}")\n',
    "hetao_ag/water/__init__.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag.water - 水循环模块\n\n蒸散发计算、水量平衡和灌溉调度。\n\n作者: Hetao College\n版本: 1.0.0\n"""\n\nfrom .evapotranspiration import (\n    eto_penman_monteith,\n    eto_hargreaves,\n    extraterrestrial_radiation,\n    crop_coefficient,\n    etc_crop,\n    WeatherData,\n    ETMethod,\n)\n\nfrom .balance import (\n    WaterBalance,\n    WaterBalanceRecord,\n)\n\nfrom .irrigation import (\n    IrrigationScheduler,\n    IrrigationEvent,\n    IrrigationRecommendation,\n    IrrigationMethod,\n    ScheduleType,\n    calculate_net_irrigation_requirement,\n    gross_irrigation_requirement,\n)\n\n__all__ = [\n    # evapotranspiration\n    "eto_penman_monteith",\n    "eto_hargreaves",\n    "extraterrestrial_radiation",\n    "crop_coefficient",\n    "etc_crop",\n    "WeatherData",\n    "ETMethod",\n    # balance\n    "WaterBalance",\n    "WaterBalanceRecord",\n    # irrigation\n    "IrrigationScheduler",\n    "IrrigationEvent",\n    "IrrigationRecommendation",\n    "IrrigationMethod",\n    "ScheduleType",\n    "calculate_net_irrigation_requirement",\n    "gross_irrigation_requirement",\n]\n',
    "hetao_ag/water/balance.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag.water.balance - 水量平衡模型\n\n农田水量平衡核算和跟踪。\n\n作者: Hetao College\n版本: 1.0.0\n"""\n\nimport numpy as np\nfrom dataclasses import dataclass, field\nfrom typing import List, Optional\nfrom datetime import date\n\n\n@dataclass\nclass WaterBalanceRecord:\n    """水量平衡日记录"""\n    date: Optional[date] = None\n    precipitation_mm: float = 0.0\n    irrigation_mm: float = 0.0\n    et_mm: float = 0.0\n    runoff_mm: float = 0.0\n    drainage_mm: float = 0.0\n    soil_moisture: float = 0.0\n    \n    @property\n    def net_change(self) -> float:\n        """净水量变化"""\n        return (self.precipitation_mm + self.irrigation_mm - \n                self.et_mm - self.runoff_mm - self.drainage_mm)\n\n\nclass WaterBalance:\n    """农田水量平衡模型\n    \n    跟踪农田水分收支,包括降水、灌溉、蒸散发、径流和渗透。\n    \n    示例:\n        >>> wb = WaterBalance(initial_storage_mm=100)\n        >>> wb.add_precipitation(25)\n        >>> wb.remove_et(5)\n        >>> print(wb.storage_mm)\n    """\n    \n    def __init__(\n        self,\n        initial_storage_mm: float = 100.0,\n        max_storage_mm: float = 150.0,\n        min_storage_mm: float = 40.0\n    ):\n        """初始化水量平衡模型\n        \n        参数:\n            initial_storage_mm: 初始储水量(mm)\n            max_storage_mm: 最大储水量(田间持水量)\n            min_storage_mm: 最小储水量(凋萎点)\n        """\n        self.storage_mm = initial_storage_mm\n        self.max_storage_mm = max_storage_mm\n        self.min_storage_mm = min_storage_mm\n        \n        # 累计量\n        self.total_precipitation = 0.0\n        self.total_irrigation = 0.0\n        self.total_et = 0.0\n        self.total_runoff = 0.0\n        self.total_drainage = 0.0\n        \n        self.history: List[WaterBalanceRecord] = []\n    \n    def add_precipitation(self, amount_mm: float) -> tuple:\n        """添加降水\n        \n        返回:\n            (入渗量, 径流量)\n        """\n        new_storage = self.storage_mm + amount_mm\n        \n        if new_storage > self.max_storage_mm:\n            runoff = new_storage - self.max_storage_mm\n            self.storage_mm = self.max_storage_mm\n        else:\n            runoff = 0.0\n            self.storage_mm = new_storage\n        \n        infiltration = amount_mm - runoff\n        self.total_precipitation += infiltration\n        self.total_runoff += runoff\n        \n        return infiltration, runoff\n    \n    def add_irrigation(self, amount_mm: float) -> float:\n        """添加灌溉\n        \n        返回:\n            实际入渗量\n        """\n        new_storage = self.storage_mm + amount_mm\n        \n        if new_storage > self.max_storage_mm:\n            overflow = new_storage - self.max_storage_mm\n            self.storage_mm = self.max_storage_mm\n            actual = amount_mm - overflow\n        else:\n            self.storage_mm = new_storage\n            actual = amount_mm\n        \n        self.total_irrigation += actual\n        return actual\n    \n    def remove_et(self, amount_mm: float) -> float:\n        """移除蒸散发\n        \n        返回:\n            实际移除量\n        """\n        new_storage = self.storage_mm - amount_mm\n        \n        if new_storage < self.min_storage_mm:\n            actual = self.storage_mm - self.min_storage_mm\n            self.storage_mm = self.min_storage_mm\n        else:\n            actual = amount_mm\n            self.storage_mm = new_storage\n        \n        self.total_et += actual\n        return actual\n    \n    def deep_drainage(self) -> float:\n        """计算深层渗漏"""\n        if self.storage_mm > self.max_storage_mm:\n            drainage = self.storage_mm - self.max_storage_mm\n            self.storage_mm = self.max_storage_mm\n            self.total_drainage += drainage\n            return drainage\n        return 0.0\n    \n    def step_day(self, precip_mm: float = 0, irrig_mm: float = 0, \n                 et_mm: float = 0, record_date: Optional[date] = None) -> WaterBalanceRecord:\n        """模拟一天\n        \n        参数:\n            precip_mm: 降水量\n            irrig_mm: 灌溉量\n            et_mm: 蒸散发量\n            record_date: 日期\n            \n        返回:\n            当日记录\n        """\n        # 输入\n        _, runoff = self.add_precipitation(precip_mm)\n        self.add_irrigation(irrig_mm)\n        \n        # 输出\n        actual_et = self.remove_et(et_mm)\n        drainage = self.deep_drainage()\n        \n        record = WaterBalanceRecord(\n            date=record_date,\n            precipitation_mm=precip_mm,\n            irrigation_mm=irrig_mm,\n            et_mm=actual_et,\n            runoff_mm=runoff,\n            drainage_mm=drainage,\n            soil_moisture=self.storage_mm\n        )\n        \n        self.history.append(record)\n        return record\n    \n    @property\n    def available_water(self) -> float:\n        """可用水量(mm)"""\n        return max(0, self.storage_mm - self.min_storage_mm)\n    \n    @property\n    def deficit_mm(self) -> float:\n        """水分亏缺(mm)"""\n        return max(0, self.max_storage_mm - self.storage_mm)\n    \n    @property\n    def relative_storage(self) -> float:\n        """相对储水量(0-1)"""\n        total_range = self.max_storage_mm - self.min_storage_mm\n        if total_range <= 0:\n            return 1.0\n        return (self.storage_mm - self.min_storage_mm) / total_range\n    \n    def water_use_efficiency(self, yield_kg_ha: float) -> float:\n        """水分利用效率(kg/m³)\n        \n        参数:\n            yield_kg_ha: 产量(kg/ha)\n            \n        返回:\n            WUE (kg/m³)\n        """\n        total_water_mm = self.total_precipitation + self.total_irrigation\n        if total_water_mm <= 0:\n            return 0.0\n        # 1mm = 10 m³/ha\n        total_water_m3_ha = total_water_mm * 10\n        return yield_kg_ha / total_water_m3_ha\n    \n    def get_summary(self) -> dict:\n        """获取水量平衡汇总"""\n        return {\n            "current_storage_mm": self.storage_mm,\n            "total_precipitation_mm": self.total_precipitation,\n            "total_irrigation_mm": self.total_irrigation,\n            "total_et_mm": self.total_et,\n            "total_runoff_mm": self.total_runoff,\n            "total_drainage_mm": self.total_drainage,\n            "available_water_mm": self.available_water,\n            "deficit_mm": self.deficit_mm\n        }\n\n\nif __name__ == "__main__":\n    print("=" * 50)\n    print("水量平衡模型演示")\n    print("=" * 50)\n    \n    wb = WaterBalance(initial_storage_mm=80, max_storage_mm=120, min_storage_mm=40)\n    \n    # 模拟10天\n    weather = [\n        {"precip": 0, "et": 5},\n        {"precip": 15, "et": 4},\n        {"precip": 0, "et": 6},\n        {"precip": 0, "et": 5},\n        {"precip": 0, "et": 5},\n        {"precip": 30, "et": 3},\n        {"precip": 0, "et": 4},\n        {"precip": 0, "et": 6},\n        {"precip": 0, "et": 5},\n        {"precip": 0, "et": 5},\n    ]\n    \n    print("\\n逐日模拟:")\n    for i, w in enumerate(weather, 1):\n        record = wb.step_day(precip_mm=w["precip"], et_mm=w["et"])\n        print(f"第{i}天: 储水={record.soil_moisture:.1f}mm, ET={record.et_mm:.1f}mm")\n    \n    print("\\n水量平衡汇总:")\n    summary = wb.get_summary()\n    for key, value in summary.items():\n        print(f"  {key}: {value:.1f}")\n',
    "hetao_ag/water/evapotranspiration.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag.water.evapotranspiration - 蒸散发计算\n\n实现FAO-56 Penman-Monteith等蒸散发计算方法。\n\n作者: Hetao College\n版本: 1.0.0\n"""\n\nimport math\nfrom dataclasses import dataclass\nfrom typing import Optional\nfrom enum import Enum\n\n\nclass ETMethod(Enum):\n    """蒸散发计算方法"""\n    PENMAN_MONTEITH = "penman_monteith"\n    HARGREAVES = "hargreaves"\n    PRIESTLEY_TAYLOR = "priestley_taylor"\n\n\n@dataclass\nclass WeatherData:\n    """气象数据\n    \n    属性:\n        t_mean: 平均气温(°C)\n        t_max: 最高气温(°C)\n        t_min: 最低气温(°C)\n        rh: 相对湿度(%)\n        u2: 2m高度风速(m/s)\n        rs: 太阳辐射(MJ/m²/day)\n        elevation: 海拔(m)\n        latitude: 纬度(度)\n        doy: 年积日\n    """\n    t_mean: float\n    t_max: float\n    t_min: float\n    rh: float = 60.0\n    u2: float = 2.0\n    rs: Optional[float] = None\n    elevation: float = 1000.0\n    latitude: float = 40.0\n    doy: int = 180\n\n\ndef eto_penman_monteith(weather: WeatherData) -> float:\n    """FAO-56 Penman-Monteith参考作物蒸散发\n    \n    国际标准方法,适用于草地参考作物。\n    \n    参数:\n        weather: WeatherData对象\n        \n    返回:\n        日参考蒸散发ET₀ (mm/day)\n        \n    参考:\n        Allen et al. (1998) FAO Irrigation and Drainage Paper 56\n    """\n    T = weather.t_mean\n    Tmax = weather.t_max\n    Tmin = weather.t_min\n    RH = weather.rh\n    u2 = weather.u2\n    elev = weather.elevation\n    lat = weather.latitude\n    doy = weather.doy\n    \n    # 太阳常数\n    Gsc = 0.0820  # MJ/m²/min\n    \n    # 饱和水汽压(kPa) - Tetens公式\n    es_tmax = 0.6108 * math.exp(17.27 * Tmax / (Tmax + 237.3))\n    es_tmin = 0.6108 * math.exp(17.27 * Tmin / (Tmin + 237.3))\n    es = (es_tmax + es_tmin) / 2.0  # 平均饱和水汽压\n    \n    # 实际水汽压\n    ea = es * RH / 100.0\n    \n    # 饱和水汽压曲线斜率(kPa/°C)\n    delta = 4098 * (0.6108 * math.exp(17.27 * T / (T + 237.3))) / ((T + 237.3) ** 2)\n    \n    # 大气压(kPa)\n    P = 101.3 * ((293 - 0.0065 * elev) / 293) ** 5.26\n    \n    # 干湿表常数\n    gamma = 0.000665 * P\n    \n    # 日地距离校正因子\n    dr = 1 + 0.033 * math.cos(2 * math.pi / 365 * doy)\n    \n    # 太阳赤纬角(rad)\n    delta_sol = 0.409 * math.sin(2 * math.pi / 365 * doy - 1.39)\n    \n    # 纬度(rad)\n    lat_rad = math.radians(lat)\n    \n    # 日落时角\n    ws = math.acos(-math.tan(lat_rad) * math.tan(delta_sol))\n    \n    # 天文辐射(MJ/m²/day)\n    Ra = (24 * 60 / math.pi) * Gsc * dr * (\n        ws * math.sin(lat_rad) * math.sin(delta_sol) +\n        math.cos(lat_rad) * math.cos(delta_sol) * math.sin(ws)\n    )\n    \n    # 太阳辐射(如未提供,用Hargreaves公式估算)\n    if weather.rs is not None:\n        Rs = weather.rs\n    else:\n        krs = 0.16  # 内陆地区系数\n        Rs = krs * math.sqrt(Tmax - Tmin) * Ra\n    \n    # 晴空辐射\n    Rso = (0.75 + 2e-5 * elev) * Ra\n    \n    # 净短波辐射(反射率0.23)\n    Rns = 0.77 * Rs\n    \n    # 净长波辐射\n    Rs_Rso = Rs / Rso if Rso > 0 else 0.5\n    Rs_Rso = min(1.0, Rs_Rso)\n    \n    Rnl = (4.903e-9 * ((Tmax + 273.16) ** 4 + (Tmin + 273.16) ** 4) / 2 *\n           (0.34 - 0.14 * math.sqrt(ea)) * (1.35 * Rs_Rso - 0.35))\n    \n    # 净辐射\n    Rn = Rns - Rnl\n    \n    # 土壤热通量(日尺度假设为0)\n    G = 0\n    \n    # FAO-56 Penman-Monteith公式\n    numerator = 0.408 * delta * (Rn - G) + gamma * (900 / (T + 273)) * u2 * (es - ea)\n    denominator = delta + gamma * (1 + 0.34 * u2)\n    \n    ET0 = numerator / denominator\n    \n    return max(0, ET0)\n\n\ndef eto_hargreaves(t_mean: float, t_max: float, t_min: float, Ra: float) -> float:\n    """Hargreaves蒸散发估算\n    \n    简化方法,仅需温度数据。\n    \n    参数:\n        t_mean: 平均气温(°C)\n        t_max: 最高气温(°C)\n        t_min: 最低气温(°C)\n        Ra: 天文辐射(MJ/m²/day)\n        \n    返回:\n        日参考蒸散发(mm/day)\n    """\n    ET0 = 0.0023 * (t_mean + 17.8) * math.sqrt(t_max - t_min) * Ra * 0.408\n    return max(0, ET0)\n\n\ndef extraterrestrial_radiation(latitude: float, doy: int) -> float:\n    """计算天文辐射\n    \n    参数:\n        latitude: 纬度(度)\n        doy: 年积日\n        \n    返回:\n        天文辐射Ra (MJ/m²/day)\n    """\n    Gsc = 0.0820\n    lat_rad = math.radians(latitude)\n    \n    dr = 1 + 0.033 * math.cos(2 * math.pi / 365 * doy)\n    delta = 0.409 * math.sin(2 * math.pi / 365 * doy - 1.39)\n    ws = math.acos(-math.tan(lat_rad) * math.tan(delta))\n    \n    Ra = (24 * 60 / math.pi) * Gsc * dr * (\n        ws * math.sin(lat_rad) * math.sin(delta) +\n        math.cos(lat_rad) * math.cos(delta) * math.sin(ws)\n    )\n    \n    return Ra\n\n\ndef crop_coefficient(growth_stage: str, crop: str = "wheat") -> float:\n    """作物系数Kc\n    \n    参数:\n        growth_stage: 生长阶段(initial, mid, late)\n        crop: 作物类型\n        \n    返回:\n        Kc值\n    """\n    KC_VALUES = {\n        "wheat": {"initial": 0.3, "mid": 1.15, "late": 0.4},\n        "maize": {"initial": 0.3, "mid": 1.20, "late": 0.6},\n        "rice": {"initial": 1.05, "mid": 1.20, "late": 0.9},\n        "cotton": {"initial": 0.35, "mid": 1.20, "late": 0.7},\n        "alfalfa": {"initial": 0.4, "mid": 0.95, "late": 0.9},\n        "sunflower": {"initial": 0.35, "mid": 1.15, "late": 0.35},\n    }\n    \n    crop_kc = KC_VALUES.get(crop.lower(), KC_VALUES["wheat"])\n    return crop_kc.get(growth_stage.lower(), 1.0)\n\n\ndef etc_crop(et0: float, kc: float, ks: float = 1.0) -> float:\n    """计算作物蒸散发ETc\n    \n    参数:\n        et0: 参考蒸散发(mm/day)\n        kc: 作物系数\n        ks: 水分胁迫系数(0-1)\n        \n    返回:\n        作物蒸散发(mm/day)\n    """\n    return et0 * kc * ks\n\n\nif __name__ == "__main__":\n    print("=" * 50)\n    print("蒸散发计算演示")\n    print("=" * 50)\n    \n    # 创建气象数据\n    weather = WeatherData(\n        t_mean=25.0,\n        t_max=32.0,\n        t_min=18.0,\n        rh=55.0,\n        u2=2.0,\n        rs=22.0,\n        elevation=1050,\n        latitude=40.8,\n        doy=180\n    )\n    \n    # 计算ET0\n    et0_pm = eto_penman_monteith(weather)\n    print(f"\\nPenman-Monteith ET₀: {et0_pm:.2f} mm/day")\n    \n    # Hargreaves方法\n    Ra = extraterrestrial_radiation(40.8, 180)\n    et0_hg = eto_hargreaves(25.0, 32.0, 18.0, Ra)\n    print(f"Hargreaves ET₀: {et0_hg:.2f} mm/day")\n    \n    # 作物蒸散发\n    kc = crop_coefficient("mid", "wheat")\n    etc = etc_crop(et0_pm, kc)\n    print(f"\\n小麦ETc (生育中期): {etc:.2f} mm/day")\n',
    "hetao_ag/water/irrigation.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag.water.irrigation - 灌溉调度\n\n灌溉决策和调度工具。\n\n作者: Hetao College\n版本: 1.0.0\n"""\n\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Tuple\nfrom enum import Enum\nimport numpy as np\n\n\nclass IrrigationMethod(Enum):\n    """灌溉方法"""\n    FLOOD = "flood"\n    SPRINKLER = "sprinkler"\n    DRIP = "drip"\n    CENTER_PIVOT = "center_pivot"\n\n\nclass ScheduleType(Enum):\n    """调度类型"""\n    FIXED_INTERVAL = "fixed_interval"\n    SOIL_MOISTURE = "soil_moisture"\n    ET_BASED = "et_based"\n    DEFICIT = "deficit"\n\n\n@dataclass\nclass IrrigationEvent:\n    """灌溉事件"""\n    day: int\n    amount_mm: float\n    method: IrrigationMethod = IrrigationMethod.FLOOD\n    duration_hours: float = 0.0\n    ec_water: float = 1.0\n\n\n@dataclass\nclass IrrigationRecommendation:\n    """灌溉建议"""\n    should_irrigate: bool\n    amount_mm: float\n    reason: str\n    urgency: str = "normal"  # low, normal, high, critical\n\n\nclass IrrigationScheduler:\n    """灌溉调度器\n    \n    基于土壤水分、ET或固定间隔的灌溉调度。\n    \n    示例:\n        >>> scheduler = IrrigationScheduler(method=ScheduleType.SOIL_MOISTURE)\n        >>> rec = scheduler.recommend(soil_moisture=0.18, field_capacity=0.32)\n        >>> if rec.should_irrigate:\n        ...     print(f"建议灌溉 {rec.amount_mm:.1f} mm")\n    """\n    \n    def __init__(\n        self,\n        method: ScheduleType = ScheduleType.SOIL_MOISTURE,\n        trigger_threshold: float = 0.5,\n        max_application_mm: float = 50.0,\n        irrigation_efficiency: float = 0.85\n    ):\n        """初始化调度器\n        \n        参数:\n            method: 调度方法\n            trigger_threshold: 触发阈值(相对可用水分)\n            max_application_mm: 单次最大灌溉量\n            irrigation_efficiency: 灌溉效率\n        """\n        self.method = method\n        self.trigger_threshold = trigger_threshold\n        self.max_application_mm = max_application_mm\n        self.efficiency = irrigation_efficiency\n        \n        self.schedule: List[IrrigationEvent] = []\n    \n    def recommend_by_moisture(\n        self,\n        current_moisture: float,\n        field_capacity: float,\n        wilting_point: float,\n        root_depth_m: float = 0.3\n    ) -> IrrigationRecommendation:\n        """基于土壤水分的灌溉建议\n        \n        参数:\n            current_moisture: 当前含水量\n            field_capacity: 田间持水量\n            wilting_point: 凋萎点\n            root_depth_m: 根区深度\n            \n        返回:\n            IrrigationRecommendation\n        """\n        available_range = field_capacity - wilting_point\n        current_available = current_moisture - wilting_point\n        \n        if available_range <= 0:\n            return IrrigationRecommendation(False, 0, "参数错误")\n        \n        depletion_fraction = 1 - (current_available / available_range)\n        \n        # 判断是否需要灌溉\n        if depletion_fraction < self.trigger_threshold:\n            return IrrigationRecommendation(\n                should_irrigate=False,\n                amount_mm=0,\n                reason=f"土壤水分充足(亏缺{depletion_fraction*100:.0f}%)",\n                urgency="low"\n            )\n        \n        # 计算灌溉量(补充到田间持水量)\n        deficit = field_capacity - current_moisture\n        deficit_mm = deficit * root_depth_m * 1000\n        \n        # 考虑效率\n        gross_amount = deficit_mm / self.efficiency\n        amount = min(gross_amount, self.max_application_mm)\n        \n        # 紧急程度\n        if depletion_fraction > 0.8:\n            urgency = "critical"\n        elif depletion_fraction > 0.6:\n            urgency = "high"\n        else:\n            urgency = "normal"\n        \n        return IrrigationRecommendation(\n            should_irrigate=True,\n            amount_mm=amount,\n            reason=f"土壤水分亏缺{depletion_fraction*100:.0f}%",\n            urgency=urgency\n        )\n    \n    def recommend_by_et(\n        self,\n        days_since_irrigation: int,\n        cumulative_et_mm: float,\n        cumulative_rain_mm: float = 0\n    ) -> IrrigationRecommendation:\n        """基于ET的灌溉建议\n        \n        参数:\n            days_since_irrigation: 距上次灌溉天数\n            cumulative_et_mm: 累计ET\n            cumulative_rain_mm: 累计降水\n            \n        返回:\n            IrrigationRecommendation\n        """\n        net_deficit = cumulative_et_mm - cumulative_rain_mm\n        \n        if net_deficit <= 0:\n            return IrrigationRecommendation(\n                should_irrigate=False,\n                amount_mm=0,\n                reason="降水已补充水分亏缺"\n            )\n        \n        threshold_mm = self.trigger_threshold * self.max_application_mm\n        \n        if net_deficit < threshold_mm:\n            return IrrigationRecommendation(\n                should_irrigate=False,\n                amount_mm=0,\n                reason=f"净亏缺{net_deficit:.1f}mm低于阈值"\n            )\n        \n        amount = min(net_deficit / self.efficiency, self.max_application_mm)\n        \n        return IrrigationRecommendation(\n            should_irrigate=True,\n            amount_mm=amount,\n            reason=f"补充{days_since_irrigation}天ET亏缺"\n        )\n    \n    def fixed_schedule(\n        self,\n        interval_days: int,\n        amount_mm: float,\n        total_days: int,\n        start_day: int = 0\n    ) -> List[IrrigationEvent]:\n        """生成固定间隔灌溉计划\n        \n        参数:\n            interval_days: 灌溉间隔\n            amount_mm: 每次灌溉量\n            total_days: 总天数\n            start_day: 起始日\n            \n        返回:\n            灌溉事件列表\n        """\n        events = []\n        day = start_day\n        \n        while day < total_days:\n            events.append(IrrigationEvent(\n                day=day,\n                amount_mm=amount_mm\n            ))\n            day += interval_days\n        \n        self.schedule = events\n        return events\n    \n    def deficit_irrigation_schedule(\n        self,\n        full_et_mm: np.ndarray,\n        deficit_fraction: float = 0.7,\n        min_interval: int = 3\n    ) -> List[IrrigationEvent]:\n        """亏缺灌溉计划\n        \n        参数:\n            full_et_mm: 逐日完全ET需求\n            deficit_fraction: 亏缺系数(0.7=70%ET)\n            min_interval: 最小灌溉间隔\n            \n        返回:\n            灌溉事件列表\n        """\n        target_et = full_et_mm * deficit_fraction\n        events = []\n        accumulated = 0.0\n        last_irrigation_day = -min_interval\n        \n        for day, et in enumerate(target_et):\n            accumulated += et\n            \n            if (accumulated >= self.max_application_mm * 0.8 and \n                day - last_irrigation_day >= min_interval):\n                \n                amount = min(accumulated, self.max_application_mm)\n                events.append(IrrigationEvent(day=day, amount_mm=amount))\n                accumulated = 0.0\n                last_irrigation_day = day\n        \n        self.schedule = events\n        return events\n    \n    def total_irrigation(self) -> float:\n        """计算总灌溉量"""\n        return sum(e.amount_mm for e in self.schedule)\n\n\ndef calculate_net_irrigation_requirement(\n    et_mm: float,\n    effective_rain_mm: float,\n    soil_contribution_mm: float = 0\n) -> float:\n    """计算净灌溉需水量\n    \n    参数:\n        et_mm: 蒸散发量\n        effective_rain_mm: 有效降水\n        soil_contribution_mm: 土壤贡献\n        \n    返回:\n        净灌溉需水量(mm)\n    """\n    nir = et_mm - effective_rain_mm - soil_contribution_mm\n    return max(0, nir)\n\n\ndef gross_irrigation_requirement(nir_mm: float, efficiency: float = 0.85) -> float:\n    """计算毛灌溉需水量\n    \n    参数:\n        nir_mm: 净灌溉需水量\n        efficiency: 灌溉效率\n        \n    返回:\n        毛灌溉需水量(mm)\n    """\n    if efficiency <= 0:\n        return nir_mm\n    return nir_mm / efficiency\n\n\nif __name__ == "__main__":\n    print("=" * 50)\n    print("灌溉调度演示")\n    print("=" * 50)\n    \n    scheduler = IrrigationScheduler(\n        method=ScheduleType.SOIL_MOISTURE,\n        trigger_threshold=0.5\n    )\n    \n    # 基于土壤水分的建议\n    rec = scheduler.recommend_by_moisture(\n        current_moisture=0.18,\n        field_capacity=0.32,\n        wilting_point=0.12,\n        root_depth_m=0.3\n    )\n    \n    print(f"\\n是否灌溉: {rec.should_irrigate}")\n    print(f"建议量: {rec.amount_mm:.1f} mm")\n    print(f"原因: {rec.reason}")\n    print(f"紧急程度: {rec.urgency}")\n    \n    # 固定计划\n    print("\\n固定间隔灌溉计划:")\n    events = scheduler.fixed_schedule(interval_days=7, amount_mm=40, total_days=60)\n    for e in events[:5]:\n        print(f"  第{e.day}天: {e.amount_mm}mm")\n    print(f"  总灌溉量: {scheduler.total_irrigation():.0f}mm")\n',
    "tests/test_all.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag 综合测试脚本\n\n测试所有模块的导入和核心功能。\n运行方式: python tests/test_all.py\n"""\n\nimport sys\nimport traceback\n\n\ndef test_core():\n    """测试核心模块"""\n    print("\\n[1/7] 测试Core模块...")\n    from hetao_ag.core import Unit, Quantity, Dimension, DimensionError\n    from hetao_ag.core import meters, hectares, celsius, ds_per_m\n    from hetao_ag.core import ConfigManager, get_logger\n    from hetao_ag.core import safe_divide, clamp, rmse, ValidationResult\n    \n    # 测试单位\n    q = Quantity(5.5, Unit.KILOMETER)\n    assert q.to(Unit.METER).value == 5500, "单位转换失败"\n    \n    # 测试温度\n    t = celsius(25)\n    assert abs(t.to(Unit.KELVIN).value - 298.15) < 0.01, "温度转换失败"\n    \n    # 测试算术\n    a = meters(100)\n    b = meters(50)\n    assert (a + b).value == 150, "加法失败"\n    \n    # 测试工具函数\n    assert safe_divide(10, 0) == 0.0, "安全除法失败"\n    assert clamp(15, 0, 10) == 10, "clamp失败"\n    \n    print("    [OK] Core模块测试通过")\n    return True\n\n\ndef test_soil():\n    """测试土壤模块"""\n    print("\\n[2/7] 测试Soil模块...")\n    from hetao_ag.soil import (\n        SoilMoistureModel, SoilType, SalinityModel,\n        SensorCalibrator, classify_soil_salinity\n    )\n    import numpy as np\n    \n    # 水分模型\n    model = SoilMoistureModel(field_capacity=0.32, wilting_point=0.12)\n    model.step_day(rain_mm=15, et_mm=5)\n    assert 0.12 <= model.moisture <= 0.45, "土壤含水量异常"\n    \n    # 盐分分级\n    assert "非盐渍化" in classify_soil_salinity(1.5), "盐分分级失败"\n    assert "中度" in classify_soil_salinity(6.0), "盐分分级失败"\n    \n    # 传感器校准\n    calibrator = SensorCalibrator()\n    result = calibrator.linear_calibration(\n        np.array([300, 450, 600]),\n        np.array([0.10, 0.20, 0.30])\n    )\n    assert result.r_squared > 0.99, "校准R²过低"\n    \n    print("    [OK] Soil模块测试通过")\n    return True\n\n\ndef test_water():\n    """测试水循环模块"""\n    print("\\n[3/7] 测试Water模块...")\n    from hetao_ag.water import (\n        eto_penman_monteith, eto_hargreaves, WeatherData,\n        extraterrestrial_radiation, crop_coefficient, etc_crop,\n        WaterBalance, IrrigationScheduler\n    )\n    \n    # Penman-Monteith ET0\n    weather = WeatherData(\n        t_mean=25.0, t_max=32.0, t_min=18.0,\n        rh=55.0, u2=2.0, rs=22.0,\n        elevation=1050, latitude=40.8, doy=180\n    )\n    et0 = eto_penman_monteith(weather)\n    assert 3 < et0 < 10, f"ET0异常: {et0}"\n    \n    # 作物系数\n    kc = crop_coefficient("mid", "wheat")\n    assert 1.0 < kc < 1.3, "Kc异常"\n    \n    # 水量平衡\n    wb = WaterBalance(initial_storage_mm=80)\n    wb.step_day(precip_mm=20, et_mm=5)\n    assert 80 < wb.storage_mm < 100, "水量平衡异常"\n    \n    print("    [OK] Water模块测试通过")\n    return True\n\n\ndef test_crop():\n    """测试作物模块"""\n    print("\\n[4/7] 测试Crop模块...")\n    from hetao_ag.crop import (\n        yield_reduction_salinity_crop, water_stress_from_moisture,\n        combined_stress_factor, classify_salt_tolerance,\n        PhenologyTracker, CropModel\n    )\n    \n    # 盐分胁迫\n    rel_yield = yield_reduction_salinity_crop(8.0, "wheat")\n    assert 0.5 < rel_yield < 1.0, "盐分胁迫计算异常"\n    \n    # 水分胁迫\n    ks = water_stress_from_moisture(0.20, 0.32, 0.12)\n    assert 0 < ks <= 1, "水分胁迫异常"\n    \n    # 组合胁迫\n    combined = combined_stress_factor(0.8, 0.9)\n    assert abs(combined - 0.72) < 0.01, "组合胁迫计算错误"\n    \n    # 物候跟踪\n    tracker = PhenologyTracker("wheat")\n    tracker.accumulate_gdd(30, 15)\n    assert tracker.accumulated_gdd > 0, "积温累积失败"\n    \n    # 作物模型\n    model = CropModel("wheat")\n    for _ in range(10):\n        model.update_daily(t_max=25, t_min=15, et=5, soil_moisture=0.25, ECe=3.0)\n    assert model.accumulated_biomass > 0, "生物量累积失败"\n    \n    print("    [OK] Crop模块测试通过")\n    return True\n\n\ndef test_livestock():\n    """测试畜牧模块"""\n    print("\\n[5/7] 测试Livestock模块...")\n    from hetao_ag.livestock import (\n        AnimalDetector, BehaviorClassifier, AnimalBehavior,\n        HealthMonitor, HealthStatus\n    )\n    import numpy as np\n    \n    # 检测器(模拟模式)\n    detector = AnimalDetector()\n    detections = detector.detect("test.jpg")\n    assert len(detections) >= 1, "模拟检测失败"\n    \n    # 行为分类\n    classifier = BehaviorClassifier()\n    behavior = classifier.classify_from_motion(0.3, "down")\n    assert behavior == AnimalBehavior.GRAZING, "行为分类错误"\n    \n    # 健康监测\n    monitor = HealthMonitor("cow_001")\n    for _ in range(7):\n        monitor.update_activity(100 + np.random.randn() * 5)\n    monitor.update_activity(60)  # 模拟异常\n    alerts = monitor.check_health()\n    assert len(alerts) >= 1, "健康预警失败"\n    \n    print("    [OK] Livestock模块测试通过")\n    return True\n\n\ndef test_space():\n    """测试遥感模块"""\n    print("\\n[6/7] 测试Space模块...")\n    from hetao_ag.space import (\n        compute_ndvi, compute_savi, compute_lswi, compute_evi,\n        classify_vegetation_health, RasterImage, PhenologyClassifier\n    )\n    import numpy as np\n    \n    # NDVI计算\n    red = np.array([[100, 120], [110, 90]])\n    nir = np.array([[200, 220], [190, 170]])\n    ndvi = compute_ndvi(red, nir)\n    assert ndvi.shape == (2, 2), "NDVI形状错误"\n    assert -1 <= ndvi.min() <= ndvi.max() <= 1, "NDVI范围错误"\n    \n    # SAVI\n    savi = compute_savi(red, nir, L=0.5)\n    assert savi.shape == (2, 2), "SAVI形状错误"\n    \n    # 植被分类\n    health = classify_vegetation_health(0.65)\n    assert "茂密" in health, "植被分类错误"\n    \n    # 物候分类\n    ts = np.random.rand(12, 10, 10)\n    classifier = PhenologyClassifier(ts)\n    crop_map = classifier.classify_crops()\n    assert crop_map.shape == (10, 10), "分类结果形状错误"\n    \n    print("    [OK] Space模块测试通过")\n    return True\n\n\ndef test_opt():\n    """测试优化模块"""\n    print("\\n[7/7] 测试Opt模块...")\n    from hetao_ag.opt import (\n        LinearOptimizer, optimize_crop_mix,\n        GeneticOptimizer, GAConfig,\n        ScenarioEvaluator, multi_objective_score\n    )\n    \n    # 线性优化\n    crops = [\n        {"name": "wheat", "profit_per_ha": 500, "water_per_ha": 3000},\n        {"name": "maize", "profit_per_ha": 600, "water_per_ha": 5000},\n    ]\n    solution = optimize_crop_mix(crops, total_land=100, total_water=300000)\n    assert len(solution) >= 1, "作物组合优化失败"\n    \n    # 遗传算法\n    def sphere(x):\n        return -sum(xi**2 for xi in x)\n    \n    optimizer = GeneticOptimizer(\n        sphere, n_vars=2,\n        bounds=[(-5, 5)] * 2,\n        config=GAConfig(generations=20, population_size=20)\n    )\n    result = optimizer.optimize()\n    assert result.best_fitness > -1, "GA优化失败"\n    \n    # 多目标评分\n    score = multi_objective_score(0.8, 0.7, 0.9)\n    assert 0 < score < 1, "多目标评分失败"\n    \n    print("    [OK] Opt模块测试通过")\n    return True\n\n\ndef main():\n    print("=" * 60)\n    print("  hetao_ag 智慧农牧业库 - 综合测试")\n    print("=" * 60)\n    \n    tests = [\n        ("core", test_core),\n        ("soil", test_soil),\n        ("water", test_water),\n        ("crop", test_crop),\n        ("livestock", test_livestock),\n        ("space", test_space),\n        ("opt", test_opt),\n    ]\n    \n    results = []\n    for name, test_func in tests:\n        try:\n            success = test_func()\n            results.append((name, success, None))\n        except Exception as e:\n            results.append((name, False, str(e)))\n            print(f"    [FAIL] {name}模块测试失败: {e}")\n            traceback.print_exc()\n    \n    print("\\n" + "=" * 60)\n    print("测试总结")\n    print("=" * 60)\n    \n    passed = sum(1 for _, success, _ in results if success)\n    total = len(results)\n    \n    for name, success, error in results:\n        status = "[OK] 通过" if success else f"[FAIL] 失败: {error}"\n        print(f"  {name}: {status}")\n    \n    print(f"\\n总计: {passed}/{total} 模块测试通过")\n    \n    if passed == total:\n        print("\\n[OK] 所有测试通过！库已达到国际顶级标准。")\n        return 0\n    else:\n        print("\\n[FAIL] 部分测试失败，需要修复。")\n        return 1\n\n\nif __name__ == "__main__":\n    sys.exit(main())\n',
    "examples/demo.py": '# -*- coding: utf-8 -*-\n"""\nhetao_ag 综合使用示例\n\n演示智慧农牧业库的主要功能。\n\n作者: Hetao College\n"""\n\nimport numpy as np\nfrom datetime import date\n\n\ndef demo_core_module():\n    """核心模块演示"""\n    print("\\n" + "=" * 60)\n    print("【1. 核心模块 - 单位系统和配置】")\n    print("=" * 60)\n    \n    from hetao_ag.core import (\n        Quantity, Unit, meters, hectares, celsius, ds_per_m,\n        get_logger, ConfigManager, create_default_config\n    )\n    \n    # 单位转换\n    distance = Quantity(5.5, Unit.KILOMETER)\n    print(f"距离: {distance} = {distance.to(Unit.METER)}")\n    \n    # 面积计算\n    farm_area = hectares(150)\n    print(f"农场面积: {farm_area}")\n    \n    # 温度\n    temp = celsius(28.5)\n    print(f"温度: {temp} = {temp.to(Unit.KELVIN)}")\n    \n    # 土壤盐分\n    soil_ec = ds_per_m(4.5)\n    print(f"土壤电导率: {soil_ec}")\n    \n    # 日志\n    logger = get_logger("demo")\n    logger.info("系统初始化完成")\n\n\ndef demo_soil_module():\n    """土壤模块演示"""\n    print("\\n" + "=" * 60)\n    print("【2. 土壤模块 - 水分和盐分建模】")\n    print("=" * 60)\n    \n    from hetao_ag.soil import (\n        SoilMoistureModel, SoilType, SalinityModel,\n        SensorCalibrator, classify_soil_salinity\n    )\n    \n    # 土壤水分模型\n    moisture_model = SoilMoistureModel(\n        field_capacity=0.32,\n        wilting_point=0.12,\n        initial_moisture=0.25,\n        soil_type=SoilType.LOAM\n    )\n    \n    print(f"初始含水量: {moisture_model.moisture:.3f}")\n    print(f"需灌溉量: {moisture_model.irrigation_need_mm:.1f} mm")\n    \n    # 模拟降水\n    result = moisture_model.step_day(rain_mm=20, et_mm=5)\n    print(f"降水后含水量: {result[\'moisture\']:.3f}")\n    \n    # 盐分模型\n    salinity_model = SalinityModel(initial_ECe=4.0)\n    print(f"\\n土壤EC: {salinity_model.ECe:.1f} dS/m")\n    print(f"等级: {classify_soil_salinity(salinity_model.ECe)}")\n    \n    # 传感器校准\n    calibrator = SensorCalibrator()\n    raw_vals = np.array([300, 450, 600, 750])\n    true_vals = np.array([0.10, 0.20, 0.30, 0.40])\n    result = calibrator.linear_calibration(raw_vals, true_vals)\n    print(f"\\n传感器校准: {result}")\n\n\ndef demo_water_module():\n    """水循环模块演示"""\n    print("\\n" + "=" * 60)\n    print("【3. 水循环模块 - 蒸散发和灌溉】")\n    print("=" * 60)\n    \n    from hetao_ag.water import (\n        eto_penman_monteith, eto_hargreaves, WeatherData,\n        extraterrestrial_radiation, crop_coefficient, etc_crop,\n        WaterBalance, IrrigationScheduler, ScheduleType\n    )\n    \n    # FAO-56 Penman-Monteith\n    weather = WeatherData(\n        t_mean=25.0, t_max=32.0, t_min=18.0,\n        rh=55.0, u2=2.0, rs=22.0,\n        elevation=1050, latitude=40.8, doy=180\n    )\n    \n    et0 = eto_penman_monteith(weather)\n    print(f"Penman-Monteith ET₀: {et0:.2f} mm/day")\n    \n    # Hargreaves方法\n    Ra = extraterrestrial_radiation(40.8, 180)\n    et0_hg = eto_hargreaves(25.0, 32.0, 18.0, Ra)\n    print(f"Hargreaves ET₀: {et0_hg:.2f} mm/day")\n    \n    # 作物蒸散发\n    kc = crop_coefficient("mid", "wheat")\n    etc = etc_crop(et0, kc)\n    print(f"小麦ETc (Kc={kc}): {etc:.2f} mm/day")\n    \n    # 水量平衡\n    wb = WaterBalance(initial_storage_mm=80, max_storage_mm=120)\n    wb.step_day(precip_mm=15, et_mm=5)\n    print(f"\\n土壤储水: {wb.storage_mm:.1f} mm")\n    \n    # 灌溉调度\n    scheduler = IrrigationScheduler(method=ScheduleType.SOIL_MOISTURE)\n    rec = scheduler.recommend_by_moisture(0.18, 0.32, 0.12)\n    print(f"灌溉建议: {\'是\' if rec.should_irrigate else \'否\'}, {rec.amount_mm:.1f} mm")\n\n\ndef demo_crop_module():\n    """作物模块演示"""\n    print("\\n" + "=" * 60)\n    print("【4. 作物模块 - 生长和胁迫】")\n    print("=" * 60)\n    \n    from hetao_ag.crop import (\n        CropModel, PhenologyTracker, GrowthStage,\n        yield_reduction_salinity_crop, water_stress_from_moisture,\n        classify_salt_tolerance\n    )\n    \n    # 盐分胁迫\n    crops = ["wheat", "maize", "cotton"]\n    ECe = 6.0\n    print(f"土壤EC={ECe} dS/m时的相对产量:")\n    for crop in crops:\n        rel_yield = yield_reduction_salinity_crop(ECe, crop)\n        tolerance = classify_salt_tolerance(crop)\n        print(f"  {crop}: {rel_yield*100:.1f}% ({tolerance})")\n    \n    # 水分胁迫\n    ks = water_stress_from_moisture(0.20, 0.32, 0.12)\n    print(f"\\n水分胁迫因子Ks: {ks:.3f}")\n    \n    # 物候期跟踪\n    tracker = PhenologyTracker("wheat")\n    for _ in range(30):\n        tracker.accumulate_gdd(25 + np.random.randn()*3, 15 + np.random.randn()*2)\n    print(f"\\n积温: {tracker.accumulated_gdd:.0f}")\n    print(f"生长阶段: {tracker.current_stage.value}")\n    \n    # 作物生长模型\n    model = CropModel("wheat")\n    for _ in range(60):\n        model.update_daily(t_max=26, t_min=14, et=5, soil_moisture=0.25, ECe=3.0)\n    print(f"\\n生物量: {model.accumulated_biomass:.0f} kg/ha")\n    print(f"预估产量: {model.estimate_yield():.0f} kg/ha")\n\n\ndef demo_livestock_module():\n    """畜牧模块演示"""\n    print("\\n" + "=" * 60)\n    print("【5. 畜牧模块 - 检测和健康监测】")\n    print("=" * 60)\n    \n    from hetao_ag.livestock import (\n        AnimalDetector, BehaviorClassifier, AnimalBehavior,\n        HealthMonitor, HealthStatus\n    )\n    \n    # 动物检测(模拟)\n    detector = AnimalDetector(confidence_threshold=0.5)\n    detections = detector.detect("farm_image.jpg")\n    print(f"检测到 {len(detections)} 个目标")\n    for det in detections:\n        print(f"  {det.label}: 置信度={det.confidence:.2f}")\n    \n    # 行为分类\n    classifier = BehaviorClassifier()\n    behavior = classifier.classify_from_motion(0.3, "down")\n    print(f"\\n行为分类: {behavior.value}")\n    \n    # 健康监测\n    monitor = HealthMonitor("cow_001")\n    for _ in range(7):\n        monitor.update_activity(100 + np.random.randn() * 5)\n        monitor.update_feeding_time(240 + np.random.randn() * 10)\n    \n    # 模拟异常\n    monitor.update_activity(60)\n    alerts = monitor.check_health()\n    \n    print(f"\\n健康状态: {monitor.get_status().value}")\n    print(f"预警数量: {len(alerts)}")\n\n\ndef demo_space_module():\n    """遥感模块演示"""\n    print("\\n" + "=" * 60)\n    print("【6. 遥感模块 - 光谱指数】")\n    print("=" * 60)\n    \n    from hetao_ag.space import (\n        compute_ndvi, compute_savi, compute_lswi,\n        classify_vegetation_health, RasterImage,\n        PhenologyClassifier\n    )\n    \n    # 计算NDVI\n    red = np.array([[120, 130], [110, 90]], dtype=np.uint16)\n    nir = np.array([[200, 210], [180, 160]], dtype=np.uint16)\n    \n    ndvi = compute_ndvi(red, nir)\n    print(f"NDVI:\\n{ndvi}")\n    print(f"平均NDVI: {ndvi.mean():.3f}")\n    \n    # SAVI(土壤调节)\n    savi = compute_savi(red, nir, L=0.5)\n    print(f"\\nSAVI (L=0.5):\\n{savi}")\n    \n    # 植被分类\n    print(f"\\nNDVI=0.65: {classify_vegetation_health(0.65)}")\n    print(f"NDVI=0.25: {classify_vegetation_health(0.25)}")\n\n\ndef demo_opt_module():\n    """优化模块演示"""\n    print("\\n" + "=" * 60)\n    print("【7. 优化模块 - 农场规划】")\n    print("=" * 60)\n    \n    from hetao_ag.opt import (\n        LinearOptimizer, optimize_crop_mix,\n        GeneticOptimizer, GAConfig,\n        ScenarioEvaluator\n    )\n    \n    # 作物组合优化\n    crops = [\n        {"name": "wheat", "profit_per_ha": 500, "water_per_ha": 3000},\n        {"name": "maize", "profit_per_ha": 600, "water_per_ha": 5000},\n        {"name": "alfalfa", "profit_per_ha": 400, "water_per_ha": 2000},\n    ]\n    \n    solution = optimize_crop_mix(crops, total_land=100, total_water=300000)\n    print("优化种植方案:")\n    for crop, area in solution.items():\n        if area and area > 0:\n            print(f"  {crop}: {area:.1f} ha")\n    \n    # 遗传算法示例\n    def sphere(x):\n        return -sum(xi**2 for xi in x)\n    \n    optimizer = GeneticOptimizer(\n        sphere, n_vars=3,\n        bounds=[(-5, 5)] * 3,\n        config=GAConfig(generations=30)\n    )\n    result = optimizer.optimize()\n    print(f"\\nGA优化: 最优解={[f\'{x:.3f}\' for x in result.best_solution]}")\n\n\ndef main():\n    """主演示函数"""\n    print("=" * 60)\n    print("   河套智慧农牧业库 (hetao_ag) - 综合演示")\n    print("=" * 60)\n    print("\\n本演示展示hetao_ag库的7个核心模块功能。")\n    \n    try:\n        demo_core_module()\n        demo_soil_module()\n        demo_water_module()\n        demo_crop_module()\n        demo_livestock_module()\n        demo_space_module()\n        demo_opt_module()\n        \n        print("\\n" + "=" * 60)\n        print("演示完成！所有模块运行正常。")\n        print("=" * 60)\n        \n    except Exception as e:\n        print(f"\\n错误: {e}")\n        import traceback\n        traceback.print_exc()\n\n\nif __name__ == "__main__":\n    main()\n',
    "examples/example_core.py": '# -*- coding: utf-8 -*-\n"""\nCore模块使用示例\n================\n\n演示hetao_ag.core模块的核心功能：单位系统、配置管理、日志和工具函数。\n\n作者: Hetao College\n"""\n\nfrom hetao_ag.core import (\n    # 单位系统\n    Unit, Quantity, Dimension, DimensionError,\n    meters, kilometers, hectares, celsius, kilopascals, ds_per_m,\n    # 配置管理  \n    ConfigManager, ConfigError, create_default_config,\n    # 日志\n    Logger, get_logger,\n    # 工具函数\n    safe_divide, clamp, linear_interpolate, day_of_year,\n    rmse, mae, r_squared, validate_model, ValidationResult, Timer\n)\nimport numpy as np\n\n\ndef example_unit_system():\n    """\n    示例1: 单位系统\n    ===============\n    \n    hetao_ag使用SI国际单位制，提供物理量的自动转换和算术运算。\n    这确保了科学计算的准确性，避免单位混淆导致的错误。\n    """\n    print("\\n" + "=" * 60)\n    print("示例1: 单位系统")\n    print("=" * 60)\n    \n    # 1.1 创建物理量\n    # 使用Quantity类或便捷函数\n    distance1 = Quantity(5.5, Unit.KILOMETER)\n    distance2 = kilometers(5.5)  # 等效写法\n    \n    print(f"\\n距离: {distance1}")\n    print(f"等效: {distance2}")\n    \n    # 1.2 单位转换\n    # 自动转换为目标单位\n    distance_m = distance1.to(Unit.METER)\n    print(f"转换为米: {distance_m}")\n    \n    # 1.3 温度转换（特殊处理摄氏度-开尔文偏移）\n    temp_c = celsius(25.0)\n    temp_k = temp_c.to(Unit.KELVIN)\n    print(f"\\n温度: {temp_c} = {temp_k}")\n    \n    # 1.4 农业常用单位\n    farm_area = hectares(150)  # 150公顷农场\n    soil_ec = ds_per_m(4.5)    # 土壤电导率\n    pressure = kilopascals(101.3)  # 大气压\n    \n    print(f"\\n农场面积: {farm_area}")\n    print(f"土壤电导率: {soil_ec}")\n    print(f"大气压: {pressure}")\n    \n    # 1.5 算术运算\n    # 相同维度的物理量可以进行加减运算\n    a = meters(100)\n    b = meters(50)\n    c = Quantity(0.2, Unit.KILOMETER)  # 200米\n    \n    print(f"\\n算术运算:")\n    print(f"  {a} + {b} = {a + b}")\n    print(f"  {a} - {b} = {a - b}")\n    print(f"  {a} + {c.to(Unit.METER)} = {a + c}")  # 自动转换后相加\n    \n    # 1.6 数值乘除\n    doubled = a * 2\n    half = a / 2\n    print(f"  {a} × 2 = {doubled}")\n    print(f"  {a} ÷ 2 = {half}")\n    \n    # 1.7 比较运算\n    print(f"\\n比较运算:")\n    print(f"  {a} > {b}: {a > b}")\n    print(f"  {a} == {meters(100)}: {a == meters(100)}")\n    \n    # 1.8 维度检查\n    # 不同维度的物理量相加会抛出异常\n    try:\n        result = meters(100) + celsius(25)  # 错误：长度不能与温度相加\n    except DimensionError as e:\n        print(f"\\n维度错误(预期): {e}")\n\n\ndef example_config_manager():\n    """\n    示例2: 配置管理\n    ===============\n    \n    ConfigManager支持YAML/JSON配置文件、环境变量覆盖、嵌套键访问等功能。\n    这对于可复现的科学研究和灵活的系统部署至关重要。\n    """\n    print("\\n" + "=" * 60)\n    print("示例2: 配置管理")\n    print("=" * 60)\n    \n    # 2.1 创建默认配置\n    default_config = create_default_config()\n    print(f"\\n默认配置项数: {len(default_config)}")\n    \n    # 2.2 从默认值初始化ConfigManager\n    config = ConfigManager(defaults=default_config)\n    \n    # 2.3 获取配置项（支持嵌套键）\n    soil_fc = config.get("soil.field_capacity")\n    print(f"土壤田间持水量: {soil_fc}")\n    \n    base_temp = config.get("crop.thermal_time_base_celsius")\n    print(f"作物基础温度: {base_temp}°C")\n    \n    # 2.4 带默认值的获取\n    custom_param = config.get("custom.param", default=42)\n    print(f"自定义参数(使用默认值): {custom_param}")\n    \n    # 2.5 设置配置项\n    config.set("irrigation.efficiency", 0.90)\n    print(f"\\n设置灌溉效率: {config.get(\'irrigation.efficiency\')}")\n    \n    # 2.6 检查配置项是否存在\n    print(f"\\n\'soil.field_capacity\'存在: {config.has(\'soil.field_capacity\')}")\n    print(f"\'unknown.key\'存在: {config.has(\'unknown.key\')}")\n    \n    # 2.7 验证必需配置\n    required_keys = ["soil.field_capacity", "soil.wilting_point"]\n    is_valid = config.validate(required_keys)\n    print(f"\\n配置验证通过: {is_valid}")\n\n\ndef example_logger():\n    """\n    示例3: 日志系统\n    ===============\n    \n    Logger提供统一的日志接口，支持彩色控制台输出、文件轮转和实验追踪。\n    """\n    print("\\n" + "=" * 60)\n    print("示例3: 日志系统")\n    print("=" * 60)\n    \n    # 3.1 获取日志器\n    logger = get_logger("hetao_demo")\n    \n    # 3.2 不同级别的日志\n    print("\\n日志输出演示:")\n    logger.debug("这是调试信息")\n    logger.info("这是普通信息")\n    logger.warning("这是警告信息")\n    \n    # 3.3 带额外信息的结构化日志\n    logger.info("灌溉事件", amount_mm=35, field_id="F001")\n    \n    # 3.4 实验追踪\n    logger.log_experiment_start(\n        experiment_name="灌溉优化实验",\n        parameters={"method": "deficit", "target_etc": 0.8},\n        random_seed=42\n    )\n    \n    # ... 实验代码 ...\n    \n    logger.log_experiment_end(\n        success=True,\n        results={"water_saved": 15.2, "yield_ratio": 0.95}\n    )\n\n\ndef example_utility_functions():\n    """\n    示例4: 工具函数\n    ===============\n    \n    提供常用的数学计算、插值、模型验证等实用函数。\n    """\n    print("\\n" + "=" * 60)\n    print("示例4: 工具函数")\n    print("=" * 60)\n    \n    # 4.1 安全除法\n    result = safe_divide(10, 0)  # 除零返回默认值0\n    print(f"\\n安全除法 10/0 = {result}")\n    \n    result = safe_divide(10, 0, default=-1)  # 自定义默认值\n    print(f"安全除法 10/0 (默认-1) = {result}")\n    \n    # 4.2 值限制\n    value = clamp(15, min_val=0, max_val=10)\n    print(f"\\nclamp(15, 0, 10) = {value}")\n    \n    value = clamp(-5, min_val=0, max_val=10)\n    print(f"clamp(-5, 0, 10) = {value}")\n    \n    # 4.3 线性插值\n    y = linear_interpolate(x=1.5, x1=1, y1=10, x2=2, y2=20)\n    print(f"\\n线性插值 f(1.5) = {y}")\n    \n    # 4.4 年积日计算\n    from datetime import date\n    doy = day_of_year(date(2024, 7, 15))\n    print(f"\\n2024年7月15日是第{doy}天")\n    \n    # 4.5 模型验证指标\n    observed = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    predicted = np.array([1.1, 1.9, 3.2, 3.8, 5.1])\n    \n    print(f"\\n模型验证指标:")\n    print(f"  RMSE: {rmse(observed, predicted):.4f}")\n    print(f"  MAE:  {mae(observed, predicted):.4f}")\n    print(f"  R^2:  {r_squared(observed, predicted):.4f}")\n    \n    # 4.6 综合验证\n    result = validate_model(observed, predicted)\n    print(f"\\n{result}")\n    \n    # 4.7 计时器\n    print("\\n计时器演示:")\n    with Timer("模拟计算"):\n        # 模拟耗时计算\n        total = sum(range(500000))\n\n\nif __name__ == "__main__":\n    print("=" * 60)\n    print("  hetao_ag.core 模块使用示例")\n    print("=" * 60)\n    \n    example_unit_system()\n    example_config_manager()\n    example_logger()\n    example_utility_functions()\n    \n    print("\\n" + "=" * 60)\n    print("Core模块示例完成")\n    print("=" * 60)\n',
    "examples/example_crop.py": '# -*- coding: utf-8 -*-\n"""\nCrop模块使用示例\n================\n\n演示hetao_ag.crop模块的作物生长模拟、胁迫响应和物候期管理功能。\n\n作者: Hetao College\n"""\n\nimport numpy as np\nfrom hetao_ag.crop import (\n    # 胁迫响应\n    yield_reduction_salinity, yield_reduction_salinity_crop,\n    water_stress_factor, water_stress_from_moisture,\n    combined_stress_factor, yield_with_stress,\n    classify_salt_tolerance, CropSaltTolerance, CROP_SALT_TOLERANCE,\n    # 物候期\n    PhenologyTracker, PhenologyConfig, GrowthStage,\n    growing_degree_days, CROP_PHENOLOGY,\n    # 生长模型\n    CropModel, CropConfig, simulate_growing_season, CROP_CONFIGS\n)\n\n\ndef example_salt_stress():\n    """\n    示例1: 盐分胁迫响应\n    ===================\n    \n    基于Maas-Hoffman模型计算盐分对作物产量的影响。\n    这对河套灌区等盐渍化地区的作物选择至关重要。\n    """\n    print("\\n" + "=" * 60)\n    print("示例1: 盐分胁迫响应 (Maas-Hoffman模型)")\n    print("=" * 60)\n    \n    # 1.1 作物盐分耐受性参数\n    print("\\n【作物盐分耐受性参数】")\n    print(f"{\'作物\':>10} {\'阈值(dS/m)\':>12} {\'斜率(%/dS/m)\':>14} {\'耐盐等级\':>12}")\n    print("-" * 52)\n    \n    crops = ["barley", "wheat", "cotton", "maize", "rice", "potato"]\n    for crop in crops:\n        tolerance = CROP_SALT_TOLERANCE.get(crop)\n        if tolerance:\n            grade = classify_salt_tolerance(crop)\n            print(f"{crop:>10} {tolerance.threshold:>12.1f} {tolerance.slope*100:>14.1f} {grade:>12}")\n    \n    # 1.2 计算不同EC下的产量\n    print("\\n【不同土壤EC下的相对产量】")\n    ec_levels = [2, 4, 6, 8, 10, 12]\n    \n    print(f"{\'EC(dS/m)\':>10}", end="")\n    for ec in ec_levels:\n        print(f"{ec:>8}", end="")\n    print()\n    print("-" * 60)\n    \n    for crop in ["wheat", "maize", "cotton", "barley"]:\n        print(f"{crop:>10}", end="")\n        for ec in ec_levels:\n            rel_yield = yield_reduction_salinity_crop(ec, crop)\n            print(f"{rel_yield*100:>7.0f}%", end="")\n        print()\n    \n    # 1.3 自定义参数计算\n    print("\\n【自定义参数计算】")\n    # 假设某未知品种: 阈值5 dS/m, 斜率8%/dS/m\n    ECe = 8.0\n    rel_yield = yield_reduction_salinity(ECe, threshold=5.0, slope=0.08)\n    print(f"  阈值=5.0, 斜率=8%/dS/m")\n    print(f"  ECe={ECe} dS/m时相对产量: {rel_yield*100:.1f}%")\n    \n    # 1.4 产量估算\n    print("\\n【实际产量估算】")\n    potential_yield = 6000  # kg/ha\n    ECe = 7.0\n    \n    wheat_yield = yield_reduction_salinity_crop(ECe, "wheat") * potential_yield\n    maize_yield = yield_reduction_salinity_crop(ECe, "maize") * potential_yield\n    \n    print(f"  潜在产量: {potential_yield} kg/ha")\n    print(f"  土壤EC: {ECe} dS/m")\n    print(f"  小麦实际产量: {wheat_yield:.0f} kg/ha")\n    print(f"  玉米实际产量: {maize_yield:.0f} kg/ha")\n\n\ndef example_water_stress():\n    """\n    示例2: 水分胁迫响应\n    ===================\n    \n    计算土壤水分对作物生长的影响。\n    """\n    print("\\n" + "=" * 60)\n    print("示例2: 水分胁迫响应")\n    print("=" * 60)\n    \n    # 2.1 基于土壤水分的胁迫因子\n    print("\\n【水分胁迫因子Ks】")\n    print(f"{\'含水量\':>8} {\'Ks\':>8} {\'状态\':>12}")\n    print("-" * 32)\n    \n    fc = 0.32  # 田间持水量\n    wp = 0.12  # 凋萎点\n    \n    moisture_levels = [0.32, 0.28, 0.24, 0.20, 0.16, 0.12]\n    for moisture in moisture_levels:\n        ks = water_stress_from_moisture(moisture, fc, wp)\n        if ks >= 0.9:\n            status = "无胁迫"\n        elif ks >= 0.7:\n            status = "轻度胁迫"\n        elif ks >= 0.4:\n            status = "中度胁迫"\n        else:\n            status = "重度胁迫"\n        print(f"{moisture:>8.2f} {ks:>8.2f} {status:>12}")\n    \n    # 2.2 组合胁迫\n    print("\\n【组合胁迫因子】")\n    ks_water = 0.75\n    ks_salt = 0.85\n    \n    combined_mult = combined_stress_factor(ks_water, ks_salt, method="multiplicative")\n    combined_min = combined_stress_factor(ks_water, ks_salt, method="minimum")\n    \n    print(f"  水分胁迫因子: {ks_water}")\n    print(f"  盐分胁迫因子: {ks_salt}")\n    print(f"  乘法组合: {combined_mult:.3f}")\n    print(f"  取小值法: {combined_min:.3f}")\n    \n    # 2.3 胁迫条件下的产量\n    print("\\n【胁迫条件下的产量】")\n    potential = 8000  # kg/ha\n    \n    actual = yield_with_stress(\n        potential_yield=potential,\n        water_stress=0.80,\n        salinity_stress=0.90,\n        other_stress=1.0  # 无其他胁迫\n    )\n    \n    print(f"  潜在产量: {potential} kg/ha")\n    print(f"  水分胁迫: 0.80")\n    print(f"  盐分胁迫: 0.90")\n    print(f"  实际产量: {actual:.0f} kg/ha ({actual/potential*100:.1f}%)")\n\n\ndef example_phenology():\n    """\n    示例3: 物候期管理\n    =================\n    \n    基于积温(GDD)跟踪作物生长阶段。\n    """\n    print("\\n" + "=" * 60)\n    print("示例3: 物候期管理 (积温模型)")\n    print("=" * 60)\n    \n    # 3.1 作物物候参数\n    print("\\n【作物物候参数(需积温GDD)】")\n    print(f"{\'作物\':>8} {\'基温\':>6} {\'出苗\':>6} {\'营养\':>6} {\'开花\':>6} {\'灌浆\':>6} {\'成熟\':>6}")\n    print("-" * 50)\n    \n    for crop in ["wheat", "maize", "rice", "cotton"]:\n        config = CROP_PHENOLOGY.get(crop)\n        if config:\n            gdd = config.stage_gdd\n            print(f"{crop:>8} {config.base_temperature:>6.1f} "\n                  f"{gdd.get(\'emergence\', 0):>6.0f} {gdd.get(\'vegetative\', 0):>6.0f} "\n                  f"{gdd.get(\'flowering\', 0):>6.0f} {gdd.get(\'grain_fill\', 0):>6.0f} "\n                  f"{gdd.get(\'maturity\', 0):>6.0f}")\n    \n    # 3.2 创建物候跟踪器\n    tracker = PhenologyTracker("wheat")\n    \n    print(f"\\n【小麦物候跟踪】")\n    print(f"  基础温度: {tracker.config.base_temperature}°C")\n    \n    # 3.3 模拟积温累积\n    np.random.seed(42)\n    \n    print(f"\\n{\'天数\':>4} {\'Tmax\':>6} {\'Tmin\':>6} {\'日GDD\':>8} {\'累积GDD\':>10} {\'阶段\':>12}")\n    print("-" * 55)\n    \n    for day in range(1, 121):\n        # 模拟温度(春播小麦)\n        t_max = 15 + 15 * np.sin((day - 30) / 120 * np.pi) + np.random.randn() * 2\n        t_min = t_max - 10 + np.random.randn()\n        \n        daily_gdd = tracker.accumulate_gdd(t_max, t_min)\n        \n        if day % 20 == 0 or day == 1:\n            print(f"{day:>4} {t_max:>6.1f} {t_min:>6.1f} {daily_gdd:>8.1f} "\n                  f"{tracker.accumulated_gdd:>10.0f} {tracker.current_stage.value:>12}")\n    \n    # 3.4 物候状态\n    print(f"\\n【最终物候状态】")\n    print(f"  累积积温: {tracker.accumulated_gdd:.0f} GDD")\n    print(f"  当前阶段: {tracker.current_stage.value}")\n    print(f"  成熟进度: {tracker.progress_to_maturity()*100:.1f}%")\n    print(f"  当前Kc: {tracker.get_kc_for_stage()}")\n    \n    # 3.5 预测成熟日期\n    avg_daily_gdd = tracker.accumulated_gdd / tracker.days_after_planting\n    days_remaining = tracker.days_to_maturity(avg_daily_gdd)\n    print(f"  平均日GDD: {avg_daily_gdd:.1f}")\n    print(f"  预计剩余天数: {days_remaining}")\n\n\ndef example_crop_growth():\n    """\n    示例4: 作物生长模型\n    ===================\n    \n    综合模拟作物生长，考虑温度、水分和盐分胁迫。\n    """\n    print("\\n" + "=" * 60)\n    print("示例4: 作物生长模型")\n    print("=" * 60)\n    \n    # 4.1 作物配置参数\n    print("\\n【作物模型参数】")\n    for crop_name in ["wheat", "maize", "cotton"]:\n        config = CROP_CONFIGS.get(crop_name)\n        if config:\n            print(f"\\n  {crop_name}:")\n            print(f"    潜在产量: {config.potential_yield_kg_ha} kg/ha")\n            print(f"    收获指数: {config.harvest_index}")\n            print(f"    蒸腾效率: {config.transpiration_efficiency} kg/ha/mm")\n    \n    # 4.2 创建作物模型\n    model = CropModel("wheat")\n    \n    print(f"\\n【小麦生长模拟 (120天)】")\n    \n    # 4.3 逐日模拟\n    np.random.seed(42)\n    \n    print(f"\\n{\'天\':>4} {\'阶段\':>12} {\'LAI\':>6} {\'生物量\':>10} {\'胁迫\':>6}")\n    print("-" * 45)\n    \n    for day in range(1, 121):\n        # 模拟环境条件\n        t_max = 15 + 15 * np.sin((day - 30) / 120 * np.pi) + np.random.randn() * 2\n        t_min = t_max - 10\n        et = 3 + 3 * np.sin(day / 120 * np.pi)\n        \n        # 土壤条件\n        soil_moisture = 0.25 + 0.05 * np.sin(day / 30)\n        ECe = 3.5  # 轻度盐分\n        \n        result = model.update_daily(\n            t_max=t_max, t_min=t_min, et=et,\n            soil_moisture=soil_moisture, ECe=ECe\n        )\n        \n        if day % 20 == 0 or day == 1:\n            print(f"{day:>4} {result[\'stage\']:>12} {result[\'lai\']:>6.2f} "\n                  f"{result[\'biomass_kg_ha\']:>10.0f} {result[\'stress_factor\']:>6.2f}")\n    \n    # 4.4 最终产量\n    final_yield = model.estimate_yield()\n    \n    print(f"\\n【生长季结束】")\n    print(f"  总生物量: {model.accumulated_biomass:.0f} kg/ha")\n    print(f"  预估产量: {final_yield:.0f} kg/ha")\n    print(f"  平均胁迫因子: {np.mean(model.stress_history):.3f}")\n    \n    # 4.5 不同条件对比\n    print(f"\\n【不同ECe条件下的产量对比】")\n    \n    for ECe in [1, 4, 7, 10]:\n        result = simulate_growing_season(\n            crop="wheat",\n            weather=[{"t_max": 25, "t_min": 15, "et": 5} for _ in range(100)],\n            soil_moisture=0.26,\n            ECe=ECe\n        )\n        print(f"  ECe={ECe:>2} dS/m: 产量={result[\'yield_kg_ha\']:>5.0f} kg/ha, "\n              f"胁迫因子={result[\'avg_stress\']:.2f}")\n\n\nif __name__ == "__main__":\n    print("=" * 60)\n    print("  hetao_ag.crop 模块使用示例")\n    print("=" * 60)\n    \n    example_salt_stress()\n    example_water_stress()\n    example_phenology()\n    example_crop_growth()\n    \n    print("\\n" + "=" * 60)\n    print("Crop模块示例完成")\n    print("=" * 60)\n',
    "examples/example_livestock.py": '# -*- coding: utf-8 -*-\n"""\nLivestock模块使用示例\n=====================\n\n演示hetao_ag.livestock模块的动物检测、行为分类和健康监测功能。\n\n作者: Hetao College\n"""\n\nimport numpy as np\nfrom datetime import datetime\nfrom hetao_ag.livestock import (\n    # 视觉检测\n    AnimalDetector, Detection, calculate_iou,\n    # 行为分类\n    BehaviorClassifier, AnimalBehavior, BehaviorRecord, ActivityMonitor,\n    # 健康监测\n    HealthMonitor, HerdHealthMonitor, HealthAlert, HealthStatus, AlertType\n)\n\n\ndef example_animal_detection():\n    """\n    示例1: 动物检测\n    ===============\n    \n    基于YOLO的动物检测和计数。\n    """\n    print("\\n" + "=" * 60)\n    print("示例1: 动物检测 (YOLO)")\n    print("=" * 60)\n    \n    # 1.1 创建检测器\n    detector = AnimalDetector(\n        model_name="yolov5s",      # 模型名称\n        confidence_threshold=0.5,  # 置信度阈值\n        use_gpu=True               # 使用GPU\n    )\n    \n    print(f"\\n【检测器配置】")\n    print(f"  模型: {detector.model_name}")\n    print(f"  置信度阈值: {detector.confidence_threshold}")\n    print(f"  支持的动物: {detector.SUPPORTED_ANIMALS}")\n    \n    # 1.2 检测图像\n    # 注意: 这里使用模拟模式，实际使用需要安装PyTorch\n    detections = detector.detect("farm_image.jpg")\n    \n    print(f"\\n【检测结果】")\n    print(f"  检测到 {len(detections)} 个目标:")\n    for i, det in enumerate(detections, 1):\n        print(f"    {i}. {det.label} (置信度={det.confidence:.2f})")\n        print(f"       位置: x1={det.bbox[0]:.0f}, y1={det.bbox[1]:.0f}, "\n              f"x2={det.bbox[2]:.0f}, y2={det.bbox[3]:.0f}")\n    \n    # 1.3 动物计数\n    counts = detector.count_animals("farm_image.jpg")\n    \n    print(f"\\n【动物计数】")\n    for species, count in counts.items():\n        print(f"  {species}: {count}头")\n    \n    # 1.4 IoU计算\n    print(f"\\n【IoU计算示例】")\n    box1 = (100, 100, 200, 200)\n    box2 = (150, 150, 250, 250)\n    iou = calculate_iou(box1, box2)\n    print(f"  Box1: {box1}")\n    print(f"  Box2: {box2}")\n    print(f"  IoU: {iou:.3f}")\n\n\ndef example_behavior_classification():\n    """\n    示例2: 行为分类\n    ===============\n    \n    从运动特征识别动物行为。\n    """\n    print("\\n" + "=" * 60)\n    print("示例2: 行为分类")\n    print("=" * 60)\n    \n    # 2.1 创建行为分类器\n    classifier = BehaviorClassifier()\n    \n    print(f"\\n【行为类型】")\n    for behavior in AnimalBehavior:\n        print(f"  - {behavior.value}")\n    \n    # 2.2 基于运动特征分类\n    print(f"\\n【运动特征分类】")\n    test_cases = [\n        (0.05, "down", "静卧反刍"),\n        (0.08, "level", "静止站立"),\n        (0.25, "down", "采食"),\n        (0.30, "level", "站立"),\n        (0.60, None, "行走"),\n    ]\n    \n    print(f"{\'运动幅度\':>10} {\'头部位置\':>10} {\'识别行为\':>12} {\'说明\':>10}")\n    print("-" * 50)\n    \n    for motion, head_pos, desc in test_cases:\n        behavior = classifier.classify_from_motion(motion, head_pos)\n        print(f"{motion:>10.2f} {str(head_pos):>10} {behavior.value:>12} {desc:>10}")\n    \n    # 2.3 日行为模式分析\n    print(f"\\n【日行为模式分析】")\n    \n    # 模拟24小时行为记录\n    records = [\n        BehaviorRecord(0, "cow_001", AnimalBehavior.LYING, 0.9, 6*3600),      # 0-6点 躺卧\n        BehaviorRecord(6*3600, "cow_001", AnimalBehavior.GRAZING, 0.85, 3*3600),  # 6-9点 采食\n        BehaviorRecord(9*3600, "cow_001", AnimalBehavior.RUMINATING, 0.8, 2*3600), # 9-11点 反刍\n        BehaviorRecord(11*3600, "cow_001", AnimalBehavior.GRAZING, 0.85, 2*3600),  # 11-13点 采食\n        BehaviorRecord(13*3600, "cow_001", AnimalBehavior.LYING, 0.9, 3*3600),     # 13-16点 休息\n        BehaviorRecord(16*3600, "cow_001", AnimalBehavior.GRAZING, 0.85, 3*3600),  # 16-19点 采食\n        BehaviorRecord(19*3600, "cow_001", AnimalBehavior.RUMINATING, 0.8, 2*3600), # 19-21点 反刍\n        BehaviorRecord(21*3600, "cow_001", AnimalBehavior.LYING, 0.9, 3*3600),     # 21-24点 躺卧\n    ]\n    \n    pattern = classifier.analyze_daily_pattern(records)\n    \n    print(f"  24小时行为时间分配:")\n    for behavior, ratio in sorted(pattern.items(), key=lambda x: x[1], reverse=True):\n        hours = ratio * 24\n        print(f"    {behavior}: {hours:.1f}小时 ({ratio*100:.1f}%)")\n    \n    # 2.4 活动量监测\n    print(f"\\n【活动量监测】")\n    monitor = ActivityMonitor("cow_001")\n    \n    # 模拟7天正常活动\n    np.random.seed(42)\n    normal_activity = 100 + np.random.randn(7) * 5\n    for activity in normal_activity:\n        monitor.add_reading(activity)\n    \n    print(f"  个体ID: {monitor.animal_id}")\n    print(f"  基线活动量: {monitor.baseline:.1f}")\n    print(f"  今日活动量: {monitor.get_daily_activity():.1f}")\n    \n    # 模拟异常活动\n    monitor.add_reading(65)  # 显著下降\n    is_anomaly = monitor.detect_anomaly(threshold=0.3)\n    print(f"\\n  添加异常读数后:")\n    print(f"  当前活动量: {monitor.get_daily_activity():.1f}")\n    print(f"  检测到异常: {\'是\' if is_anomaly else \'否\'}")\n\n\ndef example_health_monitoring():\n    """\n    示例3: 健康监测\n    ===============\n    \n    综合监测动物健康状态并生成预警。\n    """\n    print("\\n" + "=" * 60)\n    print("示例3: 健康监测")\n    print("=" * 60)\n    \n    # 3.1 预警类型说明\n    print(f"\\n【健康预警类型】")\n    for alert_type in AlertType:\n        print(f"  - {alert_type.value}")\n    \n    print(f"\\n【健康状态等级】")\n    for status in HealthStatus:\n        print(f"  - {status.value}")\n    \n    # 3.2 创建个体监测器\n    monitor = HealthMonitor("cow_001")\n    \n    print(f"\\n【配置阈值】")\n    for key, value in monitor.thresholds.items():\n        print(f"  {key}: {value}")\n    \n    # 3.3 录入正常数据(建立基线)\n    print(f"\\n【建立健康基线 (7天正常数据)】")\n    np.random.seed(42)\n    \n    for day in range(7):\n        monitor.update_activity(100 + np.random.randn() * 5)\n        monitor.update_feeding_time(240 + np.random.randn() * 10)\n        monitor.update_temperature(38.5 + np.random.randn() * 0.2)\n    \n    print(f"  活动量基线: {monitor.activity_baseline:.1f}")\n    print(f"  采食时间基线: {monitor.feeding_baseline:.1f} 分钟")\n    \n    # 3.4 录入异常数据\n    print(f"\\n【录入异常数据】")\n    \n    # 场景1: 活动量下降\n    monitor.update_activity(60)  # 明显下降\n    alerts1 = monitor.check_health()\n    \n    print(f"  活动量: 60 (下降40%)")\n    for alert in alerts1:\n        print(f"    [{alert.severity.value}] {alert.alert_type.value}: {alert.message}")\n    \n    # 场景2: 发烧\n    monitor.update_temperature(40.5)\n    alerts2 = monitor.check_health()\n    \n    print(f"\\n  体温: 40.5°C (发烧)")\n    for alert in alerts2:\n        if alert.alert_type == AlertType.TEMPERATURE:\n            print(f"    [{alert.severity.value}] {alert.alert_type.value}: {alert.message}")\n    \n    # 3.5 查看健康状态\n    status = monitor.get_status()\n    print(f"\\n【当前健康状态】")\n    print(f"  状态: {status.value}")\n    print(f"  累计预警: {len(monitor.alerts)}")\n    \n    # 3.6 群体健康监测\n    print(f"\\n【群体健康监测】")\n    \n    herd = HerdHealthMonitor()\n    \n    # 添加10头牛\n    for i in range(10):\n        herd.add_animal(f"cow_{i+1:03d}")\n    \n    # 模拟数据\n    np.random.seed(123)\n    for animal_id, monitor in herd.animals.items():\n        # 建立基线\n        for _ in range(7):\n            monitor.update_activity(100 + np.random.randn() * 8)\n            monitor.update_feeding_time(240 + np.random.randn() * 15)\n        \n        # 模拟当日数据(部分个体异常)\n        if np.random.random() < 0.2:  # 20%概率异常\n            monitor.update_activity(50 + np.random.randn() * 10)\n        else:\n            monitor.update_activity(100 + np.random.randn() * 8)\n    \n    # 检查全部\n    all_alerts = herd.check_all()\n    \n    print(f"  群体规模: {len(herd.animals)}头")\n    print(f"  检测到预警: {len(all_alerts)}条")\n    \n    # 健康状态汇总\n    summary = herd.get_summary()\n    print(f"\\n  健康状态汇总:")\n    for status, count in summary.items():\n        if count > 0:\n            print(f"    {status}: {count}头")\n    \n    # 显示需要关注的个体\n    print(f"\\n  需要关注的个体:")\n    for animal_id, monitor in herd.animals.items():\n        status = monitor.get_status()\n        if status != HealthStatus.HEALTHY:\n            print(f"    {animal_id}: {status.value}")\n\n\nif __name__ == "__main__":\n    print("=" * 60)\n    print("  hetao_ag.livestock 模块使用示例")\n    print("=" * 60)\n    \n    example_animal_detection()\n    example_behavior_classification()\n    example_health_monitoring()\n    \n    print("\\n" + "=" * 60)\n    print("Livestock模块示例完成")\n    print("=" * 60)\n',
    "examples/example_opt.py": '# -*- coding: utf-8 -*-\n"""\nOpt模块使用示例\n===============\n\n演示hetao_ag.opt模块的农业优化和决策支持功能。\n\n作者: Hetao College\n"""\n\nimport numpy as np\nfrom hetao_ag.opt import (\n    # 线性规划\n    LinearOptimizer, OptimizationResult, optimize_crop_mix,\n    # 遗传算法\n    GeneticOptimizer, GAConfig, GAResult, optimize_irrigation_schedule,\n    # 农场规划\n    ScenarioEvaluator, FarmScenario, multi_objective_score\n)\n\n\ndef example_linear_optimization():\n    """\n    示例1: 线性规划优化\n    ===================\n    \n    使用线性规划解决农业资源分配问题。\n    """\n    print("\\n" + "=" * 60)\n    print("示例1: 线性规划优化")\n    print("=" * 60)\n    \n    # 1.1 问题描述\n    print("\\n【问题描述】")\n    print("  某农场有100公顷土地和30万立方米水资源")\n    print("  可种植小麦、玉米、苜蓿三种作物")\n    print("  目标: 最大化总利润")\n    \n    # 1.2 作物参数\n    crops = [\n        {"name": "wheat", "profit_per_ha": 800, "water_per_ha": 3500},\n        {"name": "maize", "profit_per_ha": 1000, "water_per_ha": 5500},\n        {"name": "alfalfa", "profit_per_ha": 600, "water_per_ha": 2500},\n    ]\n    \n    print("\\n【作物参数】")\n    print(f"{\'作物\':>10} {\'利润(元/ha)\':>14} {\'需水量(m³/ha)\':>16}")\n    print("-" * 44)\n    for c in crops:\n        print(f"{c[\'name\']:>10} {c[\'profit_per_ha\']:>14} {c[\'water_per_ha\']:>16}")\n    \n    # 1.3 使用便捷函数优化\n    solution = optimize_crop_mix(\n        crops=crops,\n        total_land=100,\n        total_water=300000\n    )\n    \n    print("\\n【优化结果】")\n    total_profit = 0\n    total_water = 0\n    for crop in crops:\n        area = solution.get(crop[\'name\'], 0)\n        if area and area > 0:\n            profit = area * crop[\'profit_per_ha\']\n            water = area * crop[\'water_per_ha\']\n            total_profit += profit\n            total_water += water\n            print(f"  {crop[\'name\']}: {area:.1f} ha (利润: {profit:.0f}元, 用水: {water:.0f}m³)")\n    \n    print(f"\\n  总利润: {total_profit:.0f} 元")\n    print(f"  总用水: {total_water:.0f} m³")\n    \n    # 1.4 使用LinearOptimizer类(更灵活)\n    print("\\n【使用LinearOptimizer类】")\n    \n    optimizer = LinearOptimizer()\n    \n    # 添加决策变量\n    optimizer.add_variable("wheat", lower=0, upper=100)\n    optimizer.add_variable("maize", lower=0, upper=100)\n    optimizer.add_variable("alfalfa", lower=0, upper=100)\n    \n    # 设置目标函数(最大化利润)\n    optimizer.set_objective(\n        {"wheat": 800, "maize": 1000, "alfalfa": 600},\n        maximize=True\n    )\n    \n    # 添加约束\n    optimizer.add_constraint(\n        {"wheat": 1, "maize": 1, "alfalfa": 1}, "<=", 100  # 土地约束\n    )\n    optimizer.add_constraint(\n        {"wheat": 3500, "maize": 5500, "alfalfa": 2500}, "<=", 300000  # 水资源约束\n    )\n    optimizer.add_constraint(\n        {"wheat": 1}, ">=", 20  # 小麦最少种20ha\n    )\n    \n    result = optimizer.solve()\n    \n    print(f"  求解状态: {result.status}")\n    print(f"  目标函数值: {result.objective_value:.0f} 元")\n    print(f"  决策变量:")\n    for name, value in result.variables.items():\n        if value and value > 0:\n            print(f"    {name}: {value:.1f} ha")\n\n\ndef example_genetic_algorithm():\n    """\n    示例2: 遗传算法优化\n    ===================\n    \n    使用遗传算法解决复杂的非线性优化问题。\n    """\n    print("\\n" + "=" * 60)\n    print("示例2: 遗传算法优化")\n    print("=" * 60)\n    \n    # 2.1 简单函数优化\n    print("\\n【函数优化示例】")\n    print("  目标: 最小化 f(x,y) = x² + y²")\n    print("  搜索范围: x,y ∈ [-10, 10]")\n    \n    def sphere_function(x):\n        """球函数(全局最小值在原点)"""\n        return -sum(xi**2 for xi in x)  # 负号因为GA是最大化\n    \n    # 配置遗传算法\n    config = GAConfig(\n        population_size=50,   # 种群大小\n        generations=100,      # 迭代代数\n        crossover_rate=0.8,   # 交叉概率\n        mutation_rate=0.1,    # 变异概率\n        elitism=2,            # 精英保留数\n        tournament_size=3     # 锦标赛选择大小\n    )\n    \n    optimizer = GeneticOptimizer(\n        fitness_func=sphere_function,\n        n_vars=2,\n        bounds=[(-10, 10), (-10, 10)],\n        config=config\n    )\n    \n    result = optimizer.optimize()\n    \n    print(f"\\n【优化结果】")\n    print(f"  最优解: x={result.best_solution[0]:.4f}, y={result.best_solution[1]:.4f}")\n    print(f"  目标函数值: {-result.best_fitness:.6f}")  # 转回正值\n    print(f"  迭代代数: {result.generations_run}")\n    \n    # 2.2 高维优化\n    print("\\n【高维优化示例】")\n    print("  目标: 10维Rosenbrock函数")\n    \n    def rosenbrock(x):\n        """Rosenbrock函数"""\n        total = 0\n        for i in range(len(x) - 1):\n            total += 100 * (x[i+1] - x[i]**2)**2 + (1 - x[i])**2\n        return -total  # 最大化负值 = 最小化正值\n    \n    optimizer_10d = GeneticOptimizer(\n        fitness_func=rosenbrock,\n        n_vars=10,\n        bounds=[(-5, 5)] * 10,\n        config=GAConfig(population_size=100, generations=200)\n    )\n    \n    result_10d = optimizer_10d.optimize()\n    \n    print(f"  最优解 (前3维): {result_10d.best_solution[:3]}")\n    print(f"  目标函数值: {-result_10d.best_fitness:.2f}")\n    \n    # 2.3 灌溉计划优化\n    print("\\n【灌溉计划优化】")\n    \n    # 模拟30天的ET需求\n    daily_et = np.array([4.0 + 2.0 * np.sin(i/30 * np.pi) for i in range(30)])\n    \n    print(f"  模拟周期: 30天")\n    print(f"  平均日ET: {daily_et.mean():.1f} mm")\n    print(f"  总ET需求: {daily_et.sum():.0f} mm")\n    \n    schedule, total_irrigation = optimize_irrigation_schedule(\n        daily_et=daily_et,\n        max_irrigation=40,\n        min_interval=3\n    )\n    \n    irrigation_days = np.where(schedule > 0)[0]\n    \n    print(f"\\n  优化灌溉计划:")\n    print(f"  灌溉天数: {len(irrigation_days)}天")\n    print(f"  灌溉日期: {irrigation_days + 1}")\n    print(f"  总灌溉量: {total_irrigation:.0f} mm")\n\n\ndef example_farm_planning():\n    """\n    示例3: 农场规划与场景分析\n    =========================\n    \n    评估和比较不同农场管理方案。\n    """\n    print("\\n" + "=" * 60)\n    print("示例3: 农场规划与场景分析")\n    print("=" * 60)\n    \n    # 3.1 作物参数\n    crop_params = {\n        "wheat": {\n            "yield_kg_ha": 6000,\n            "water_need_mm": 450,\n            "price_per_kg": 2.5,\n            "cost_per_ha": 3000\n        },\n        "maize": {\n            "yield_kg_ha": 10000,\n            "water_need_mm": 600,\n            "price_per_kg": 2.0,\n            "cost_per_ha": 4000\n        },\n        "cotton": {\n            "yield_kg_ha": 4500,\n            "water_need_mm": 700,\n            "price_per_kg": 7.0,\n            "cost_per_ha": 5000\n        },\n    }\n    \n    print("\\n【作物参数】")\n    print(f"{\'作物\':>8} {\'产量\':>10} {\'需水\':>8} {\'价格\':>8} {\'成本\':>8}")\n    print("-" * 50)\n    for crop, params in crop_params.items():\n        print(f"{crop:>8} {params[\'yield_kg_ha\']:>10} {params[\'water_need_mm\']:>8} "\n              f"{params[\'price_per_kg\']:>8.1f} {params[\'cost_per_ha\']:>8}")\n    \n    # 3.2 创建场景评估器\n    evaluator = ScenarioEvaluator(\n        crop_params=crop_params,\n        total_land=100,\n        total_water=500000\n    )\n    \n    # 3.3 定义多个方案\n    scenarios = [\n        ("全小麦", {"wheat": 100}, 500),\n        ("全玉米", {"maize": 100}, 650),\n        ("全棉花", {"cotton": 100}, 750),\n        ("均衡种植", {"wheat": 40, "maize": 40, "cotton": 20}, 550),\n        ("粮食优先", {"wheat": 60, "maize": 40}, 520),\n        ("经济作物", {"wheat": 30, "cotton": 70}, 650),\n    ]\n    \n    print("\\n【方案评估结果】")\n    print(f"{\'方案\':>12} {\'利润(万元)\':>12} {\'WUE\':>8}")\n    print("-" * 36)\n    \n    for name, areas, irrig in scenarios:\n        scenario = evaluator.evaluate_scenario(name, areas, irrig)\n        profit_wan = scenario.total_profit / 10000\n        print(f"{name:>12} {profit_wan:>12.1f} {scenario.water_use_efficiency:>8.3f}")\n    \n    # 3.4 方案比较\n    comparison = evaluator.compare_scenarios()\n    \n    print("\\n【最优方案】")\n    print(f"  最高利润方案: {comparison[\'best_profit\'].name}")\n    print(f"    利润: {comparison[\'best_profit\'].total_profit/10000:.1f} 万元")\n    print(f"  最优水效方案: {comparison[\'best_water_efficiency\'].name}")\n    print(f"    WUE: {comparison[\'best_water_efficiency\'].water_use_efficiency:.3f}")\n    \n    # 3.5 敏感性分析\n    print("\\n【敏感性分析 - 灌溉量变化】")\n    \n    base_scenario = evaluator.scenarios[3]  # 均衡种植\n    variations = [-0.2, -0.1, 0, 0.1, 0.2]\n    \n    print(f"  基准方案: {base_scenario.name}")\n    print(f"  基准灌溉: {base_scenario.irrigation_mm} mm")\n    print(f"\\n{\'变化\':>8} {\'灌溉量\':>10} {\'利润(万元)\':>14}")\n    print("-" * 36)\n    \n    sensitivity_results = evaluator.sensitivity_analysis(\n        base_scenario, "irrigation", variations\n    )\n    \n    for var, result in zip(variations, sensitivity_results):\n        profit_wan = result.total_profit / 10000\n        print(f"{var:>+8.0%} {result.irrigation_mm:>10.0f} {profit_wan:>14.1f}")\n    \n    # 3.6 多目标评分\n    print("\\n【多目标综合评分】")\n    \n    # 归一化指标\n    profits = [s.total_profit for s in evaluator.scenarios]\n    wues = [s.water_use_efficiency for s in evaluator.scenarios]\n    \n    max_profit = max(profits)\n    max_wue = max(wues)\n    \n    print(f"{\'方案\':>12} {\'利润分\':>8} {\'水效分\':>8} {\'综合分\':>8}")\n    print("-" * 40)\n    \n    for scenario in evaluator.scenarios:\n        profit_score = scenario.total_profit / max_profit\n        wue_score = scenario.water_use_efficiency / max_wue\n        sustainability = 0.8  # 假设固定\n        \n        total_score = multi_objective_score(\n            profit=profit_score,\n            water_use=wue_score,\n            sustainability=sustainability,\n            weights={"profit": 0.4, "water": 0.4, "sustainability": 0.2}\n        )\n        \n        print(f"{scenario.name:>12} {profit_score:>8.2f} {wue_score:>8.2f} {total_score:>8.2f}")\n\n\ndef example_integrated_optimization():\n    """\n    示例4: 综合优化案例\n    ===================\n    \n    结合多种方法解决实际问题。\n    """\n    print("\\n" + "=" * 60)\n    print("示例4: 综合优化案例")\n    print("=" * 60)\n    \n    print("\\n【问题】")\n    print("  河套灌区某家庭农场优化")\n    print("  - 土地: 50公顷")\n    print("  - 水权: 25万m³/年")\n    print("  - 目标: 最大化经济效益和水资源效率")\n    \n    # 4.1 第一阶段: 线性规划确定种植结构\n    print("\\n【阶段1: 种植结构优化】")\n    \n    crops = [\n        {"name": "spring_wheat", "profit_per_ha": 750, "water_per_ha": 3200},\n        {"name": "sunflower", "profit_per_ha": 900, "water_per_ha": 3800},\n        {"name": "sugar_beet", "profit_per_ha": 1100, "water_per_ha": 4500},\n    ]\n    \n    solution = optimize_crop_mix(crops, total_land=50, total_water=200000)\n    \n    print("  优化种植面积:")\n    for c in crops:\n        area = solution.get(c[\'name\'], 0)\n        if area:\n            print(f"    {c[\'name\']}: {area:.1f} ha")\n    \n    # 4.2 第二阶段: 遗传算法优化灌溉策略\n    print("\\n【阶段2: 灌溉策略优化】")\n    \n    def irrigation_fitness(params):\n        """灌溉参数适应度函数"""\n        irrigation_amount = params[0] * 100  # 0-100 -> 0-100mm\n        trigger_threshold = params[1]  # 0-1\n        \n        # 简化的产量-用水模型\n        if irrigation_amount < 30:\n            yield_ratio = irrigation_amount / 30 * 0.6\n        elif irrigation_amount < 60:\n            yield_ratio = 0.6 + (irrigation_amount - 30) / 30 * 0.35\n        else:\n            yield_ratio = 0.95 - (irrigation_amount - 60) / 40 * 0.1\n        \n        water_saved = (100 - irrigation_amount) / 100 * 0.3\n        yield_ratio = min(1.0, yield_ratio + trigger_threshold * 0.1)\n        \n        # 综合得分\n        return 0.7 * yield_ratio + 0.3 * water_saved\n    \n    optimizer = GeneticOptimizer(\n        fitness_func=irrigation_fitness,\n        n_vars=2,\n        bounds=[(0.3, 0.8), (0.4, 0.7)],\n        config=GAConfig(generations=50)\n    )\n    \n    result = optimizer.optimize()\n    \n    optimal_irrigation = result.best_solution[0] * 100\n    optimal_trigger = result.best_solution[1]\n    \n    print(f"  最优灌溉定额: {optimal_irrigation:.0f} mm/次")\n    print(f"  最优触发阈值: {optimal_trigger:.2f} (可用水消耗比)")\n    print(f"  综合得分: {result.best_fitness:.3f}")\n    \n    # 4.3 总结\n    print("\\n【优化方案总结】")\n    print("  ┌────────────────────────────────────┐")\n    print("  │ 春小麦: 按优化面积种植             │")\n    print("  │ 向日葵: 按优化面积种植             │")\n    print(f"  │ 灌溉量: {optimal_irrigation:.0f}mm/次                    │")\n    print(f"  │ 灌溉触发: 可用水消耗{optimal_trigger*100:.0f}%时         │")\n    print("  └────────────────────────────────────┘")\n\n\nif __name__ == "__main__":\n    print("=" * 60)\n    print("  hetao_ag.opt 模块使用示例")\n    print("=" * 60)\n    \n    example_linear_optimization()\n    example_genetic_algorithm()\n    example_farm_planning()\n    example_integrated_optimization()\n    \n    print("\\n" + "=" * 60)\n    print("Opt模块示例完成")\n    print("=" * 60)\n',
    "examples/example_soil.py": '# -*- coding: utf-8 -*-\n"""\nSoil模块使用示例\n================\n\n演示hetao_ag.soil模块的土壤水分、盐分建模和传感器校准功能。\n\n作者: Hetao College\n"""\n\nimport numpy as np\nfrom hetao_ag.soil import (\n    # 水分模型\n    SoilMoistureModel, SoilLayer, SoilType, SOIL_PARAMETERS,\n    van_genuchten_theta,\n    # 盐分模型\n    SalinityModel, classify_soil_salinity, classify_water_salinity,\n    # 传感器校准\n    SensorCalibrator, CalibrationResult, MoistureSensor,\n    capacitive_sensor_formula\n)\n\n\ndef example_soil_moisture():\n    """\n    示例1: 土壤水分模型\n    ===================\n    \n    模拟土壤水分动态变化，包括降水入渗、蒸散发消耗和深层渗透。\n    这是灌溉决策和作物水分管理的基础。\n    """\n    print("\\n" + "=" * 60)\n    print("示例1: 土壤水分模型")\n    print("=" * 60)\n    \n    # 1.1 查看土壤类型参数\n    print("\\n【土壤水力参数(van Genuchten)】")\n    for soil_type in [SoilType.SAND, SoilType.LOAM, SoilType.CLAY]:\n        params = SOIL_PARAMETERS[soil_type]\n        print(f"  {soil_type.value}:")\n        print(f"    θr={params[\'theta_r\']:.3f}, θs={params[\'theta_s\']:.3f}")\n        print(f"    Ks={params[\'Ks\']:.1f} mm/day")\n    \n    # 1.2 创建土壤水分模型\n    model = SoilMoistureModel(\n        field_capacity=0.32,      # 田间持水量\n        wilting_point=0.12,        # 凋萎点\n        initial_moisture=0.25,     # 初始含水量\n        root_depth_m=0.30,         # 根区深度30cm\n        soil_type=SoilType.LOAM    # 壤土\n    )\n    \n    print(f"\\n【模型初始状态】")\n    print(f"  含水量: {model.moisture:.3f} m³/m³")\n    print(f"  饱和含水量: {model.saturation:.3f}")\n    print(f"  水分胁迫因子: {model.stress_factor:.3f}")\n    print(f"  需灌溉量: {model.irrigation_need_mm:.1f} mm")\n    \n    # 1.3 模拟降水入渗\n    infiltration, runoff = model.add_water(25.0)  # 25mm降水\n    print(f"\\n【添加25mm降水】")\n    print(f"  入渗量: {infiltration:.1f} mm")\n    print(f"  地表径流: {runoff:.1f} mm")\n    print(f"  当前含水量: {model.moisture:.3f}")\n    \n    # 1.4 模拟蒸散发消耗\n    actual_et = model.remove_water(8.0)  # 8mm蒸散发\n    print(f"\\n【移除8mm蒸散发】")\n    print(f"  实际移除: {actual_et:.1f} mm")\n    print(f"  当前含水量: {model.moisture:.3f}")\n    \n    # 1.5 深层渗透\n    drainage = model.deep_percolation()\n    print(f"\\n【深层渗透】")\n    print(f"  渗透量: {drainage:.1f} mm")\n    \n    # 1.6 逐日模拟\n    model2 = SoilMoistureModel(\n        field_capacity=0.32, wilting_point=0.12,\n        initial_moisture=0.28, soil_type=SoilType.LOAM\n    )\n    \n    # 10天气象数据\n    weather_data = [\n        {"rain": 0, "et": 5},\n        {"rain": 0, "et": 6},\n        {"rain": 15, "et": 4},\n        {"rain": 0, "et": 5},\n        {"rain": 0, "et": 6},\n        {"rain": 0, "et": 5},\n        {"rain": 25, "et": 3},\n        {"rain": 5, "et": 4},\n        {"rain": 0, "et": 5},\n        {"rain": 0, "et": 6},\n    ]\n    \n    print(f"\\n【10天逐日模拟】")\n    print(f"{\'日期\':>4} {\'降水\':>6} {\'ET\':>6} {\'含水量\':>8} {\'胁迫\':>6}")\n    print("-" * 36)\n    \n    for day, w in enumerate(weather_data, 1):\n        result = model2.step_day(\n            rain_mm=w["rain"],\n            et_mm=w["et"]\n        )\n        print(f"{day:>4} {w[\'rain\']:>6.0f} {result[\'et_mm\']:>6.1f} "\n              f"{result[\'moisture\']:>8.3f} {model2.stress_factor:>6.2f}")\n    \n    print(f"\\n最终状态: 含水量={model2.moisture:.3f}, 胁迫因子={model2.stress_factor:.2f}")\n\n\ndef example_soil_salinity():\n    """\n    示例2: 土壤盐分模型\n    ===================\n    \n    模拟土壤盐分累积和淋洗过程，用于盐碱地管理。\n    这对河套灌区等盐渍化地区尤为重要。\n    """\n    print("\\n" + "=" * 60)\n    print("示例2: 土壤盐分模型")\n    print("=" * 60)\n    \n    # 2.1 盐分分级标准\n    print("\\n【土壤盐分分级标准】")\n    ec_levels = [1.0, 3.0, 5.0, 10.0, 20.0]\n    for ec in ec_levels:\n        grade = classify_soil_salinity(ec)\n        print(f"  ECe={ec:>5.1f} dS/m: {grade}")\n    \n    # 2.2 灌溉水质分级\n    print("\\n【灌溉水质分级】")\n    water_ec = [0.5, 1.5, 4.0]\n    for ec in water_ec:\n        grade = classify_water_salinity(ec)\n        print(f"  EC={ec:.1f} dS/m: {grade}")\n    \n    # 2.3 创建盐分模型\n    model = SalinityModel(\n        initial_ECe=4.0,           # 初始EC 4 dS/m (轻度盐渍化)\n        root_depth_m=0.30,         # 根区30cm\n        soil_water_content=0.28    # 土壤含水量\n    )\n    \n    print(f"\\n【盐分模型初始状态】")\n    print(f"  土壤EC: {model.ECe:.2f} dS/m")\n    print(f"  等级: {classify_soil_salinity(model.ECe)}")\n    \n    # 2.4 灌溉带入盐分\n    result = model.irrigate(amount_mm=60, ec_water=1.5)\n    print(f"\\n【灌溉60mm (EC=1.5 dS/m)】")\n    print(f"  盐分输入: {result[\'salt_input_kg_ha\']:.0f} kg/ha")\n    print(f"  灌后EC: {model.ECe:.2f} dS/m")\n    \n    # 2.5 淋洗降低盐分\n    result = model.leach(drainage_mm=40)\n    print(f"\\n【淋洗40mm】")\n    print(f"  盐分移除: {result[\'salt_removed_kg_ha\']:.0f} kg/ha")\n    print(f"  淋洗后EC: {model.ECe:.2f} dS/m")\n    \n    # 2.6 计算淋洗需求\n    lr = model.leaching_requirement(\n        ec_irrigation=1.5,   # 灌溉水EC\n        ec_threshold=4.0     # 目标土壤EC\n    )\n    print(f"\\n【淋洗需求计算】")\n    print(f"  目标EC ≤ 4.0 dS/m")\n    print(f"  淋洗系数: {lr:.3f} ({lr*100:.1f}%)")\n    \n    # 2.7 长期模拟\n    print(f"\\n【30天盐分动态模拟】")\n    model2 = SalinityModel(initial_ECe=5.0)\n    \n    for day in range(30):\n        if day % 7 == 0:  # 每周灌溉\n            model2.step_day(irrigation_mm=50, ec_irrigation=1.2, drainage_mm=15)\n        else:\n            model2.step_day(drainage_mm=2)  # 自然渗漏\n    \n    print(f"  初始EC: 5.00 dS/m")\n    print(f"  30天后EC: {model2.ECe:.2f} dS/m")\n\n\ndef example_sensor_calibration():\n    """\n    示例3: 传感器校准\n    =================\n    \n    校准低成本IoT土壤传感器，提高测量精度。\n    """\n    print("\\n" + "=" * 60)\n    print("示例3: 传感器校准")\n    print("=" * 60)\n    \n    # 3.1 准备校准数据\n    # 原始ADC读数\n    raw_readings = np.array([280, 350, 420, 500, 580, 650, 720])\n    # 烘干法测定的真实体积含水量\n    ground_truth = np.array([0.08, 0.14, 0.20, 0.26, 0.32, 0.38, 0.44])\n    \n    print("\\n【校准数据】")\n    print(f"  原始读数: {raw_readings}")\n    print(f"  真实值:   {ground_truth}")\n    \n    # 3.2 创建校准器\n    calibrator = SensorCalibrator()\n    \n    # 3.3 线性校准\n    linear_result = calibrator.linear_calibration(raw_readings, ground_truth)\n    print(f"\\n【线性校准结果】")\n    print(f"  方程: y = {linear_result.coefficients[0]:.6f}x + {linear_result.coefficients[1]:.4f}")\n    print(f"  R² = {linear_result.r_squared:.4f}")\n    print(f"  RMSE = {linear_result.rmse:.4f}")\n    \n    # 3.4 多项式校准\n    poly_result = calibrator.polynomial_calibration(raw_readings, ground_truth, degree=2)\n    print(f"\\n【二次多项式校准】")\n    print(f"  R² = {poly_result.r_squared:.4f}")\n    print(f"  RMSE = {poly_result.rmse:.4f}")\n    \n    # 3.5 自动选择最佳方法\n    best_result = calibrator.auto_calibrate(raw_readings, ground_truth)\n    print(f"\\n【自动选择最佳方法】")\n    print(f"  方法: {best_result.method.value}")\n    print(f"  R² = {best_result.r_squared:.4f}")\n    \n    # 3.6 应用校准\n    test_raw = 450\n    calibrated = best_result.apply(test_raw)\n    print(f"\\n【应用校准】")\n    print(f"  原始读数: {test_raw}")\n    print(f"  校准后含水量: {calibrated:.3f} m³/m³")\n    \n    # 3.7 创建传感器实例\n    sensor = MoistureSensor(\n        sensor_id="SM-001",\n        calibration=best_result\n    )\n    \n    # 模拟采集数据\n    import time\n    print(f"\\n【传感器数据采集】")\n    for i, raw in enumerate([400, 420, 450, 430, 440]):\n        sensor.add_reading(time.time() + i*60, raw)\n    \n    avg_moisture = sensor.get_average()\n    print(f"  最近5次平均含水量: {avg_moisture:.3f}")\n    \n    # 3.8 电容式传感器通用公式\n    print(f"\\n【电容式传感器公式】")\n    for raw in [400, 350, 300]:\n        moisture_pct = capacitive_sensor_formula(raw, dry_value=520, wet_value=260)\n        print(f"  ADC={raw} -> 湿度={moisture_pct:.1f}%")\n\n\nif __name__ == "__main__":\n    print("=" * 60)\n    print("  hetao_ag.soil 模块使用示例")\n    print("=" * 60)\n    \n    example_soil_moisture()\n    example_soil_salinity()\n    example_sensor_calibration()\n    \n    print("\\n" + "=" * 60)\n    print("Soil模块示例完成")\n    print("=" * 60)\n',
    "examples/example_space.py": '# -*- coding: utf-8 -*-\n"""\nSpace模块使用示例\n=================\n\n演示hetao_ag.space模块的遥感影像处理、光谱指数计算和物候分类功能。\n\n作者: Hetao College\n"""\n\nimport numpy as np\nfrom hetao_ag.space import (\n    # 光谱指数\n    compute_ndvi, compute_savi, compute_lswi, compute_evi, compute_ndwi,\n    classify_vegetation_health,\n    # 影像处理\n    RasterImage, GeoMetadata, CloudMask,\n    # 物候分类\n    PhenologyClassifier, PhenologyFeatures, temporal_smoothing\n)\n\n\ndef example_spectral_indices():\n    """\n    示例1: 光谱指数计算\n    ===================\n    \n    计算常用的遥感植被指数：NDVI、SAVI、LSWI、EVI等。\n    """\n    print("\\n" + "=" * 60)\n    print("示例1: 光谱指数计算")\n    print("=" * 60)\n    \n    # 1.1 模拟多光谱数据\n    # 假设4个像素的Sentinel-2数据\n    blue = np.array([[800, 850], [780, 900]], dtype=np.uint16)\n    green = np.array([[1000, 1100], [980, 1150]], dtype=np.uint16)\n    red = np.array([[1200, 1300], [1150, 1400]], dtype=np.uint16)\n    nir = np.array([[4500, 4800], [4300, 5000]], dtype=np.uint16)\n    swir = np.array([[2000, 2200], [1900, 2400]], dtype=np.uint16)\n    \n    print("\\n【模拟波段数据】")\n    print(f"  Blue: {blue.flatten()}")\n    print(f"  Green: {green.flatten()}")\n    print(f"  Red: {red.flatten()}")\n    print(f"  NIR: {nir.flatten()}")\n    print(f"  SWIR: {swir.flatten()}")\n    \n    # 1.2 NDVI (归一化差值植被指数)\n    ndvi = compute_ndvi(red, nir)\n    \n    print(f"\\n【NDVI】")\n    print(f"  公式: NDVI = (NIR - Red) / (NIR + Red)")\n    print(f"  值范围: -1 到 1")\n    print(f"  结果:\\n{ndvi}")\n    print(f"  平均NDVI: {ndvi.mean():.3f}")\n    \n    # 1.3 SAVI (土壤调节植被指数)\n    savi = compute_savi(red, nir, L=0.5)\n    \n    print(f"\\n【SAVI (L=0.5)】")\n    print(f"  公式: SAVI = ((NIR - Red) / (NIR + Red + L)) × (1 + L)")\n    print(f"  L=0.5适用于中等植被覆盖")\n    print(f"  结果:\\n{savi}")\n    \n    # 1.4 LSWI (地表水指数)\n    lswi = compute_lswi(nir, swir)\n    \n    print(f"\\n【LSWI】")\n    print(f"  公式: LSWI = (NIR - SWIR) / (NIR + SWIR)")\n    print(f"  用于监测植被水分含量")\n    print(f"  结果:\\n{lswi}")\n    \n    # 1.5 EVI (增强型植被指数)\n    evi = compute_evi(blue, red, nir)\n    \n    print(f"\\n【EVI】")\n    print(f"  优点: 对大气和土壤背景校正")\n    print(f"  结果:\\n{evi}")\n    \n    # 1.6 NDWI (归一化差值水体指数)\n    ndwi = compute_ndwi(green, nir)\n    \n    print(f"\\n【NDWI】")\n    print(f"  用于水体提取")\n    print(f"  结果:\\n{ndwi}")\n    \n    # 1.7 植被健康分级\n    print(f"\\n【植被健康分级】")\n    ndvi_values = [-0.1, 0.1, 0.3, 0.5, 0.7, 0.85]\n    for ndvi_val in ndvi_values:\n        health = classify_vegetation_health(ndvi_val)\n        print(f"  NDVI={ndvi_val:>5.2f}: {health}")\n\n\ndef example_raster_image():\n    """\n    示例2: 栅格影像处理\n    ===================\n    \n    加载和处理遥感影像数据。\n    """\n    print("\\n" + "=" * 60)\n    print("示例2: 栅格影像处理")\n    print("=" * 60)\n    \n    # 2.1 创建模拟影像\n    np.random.seed(42)\n    \n    # 模拟4波段影像 (Blue, Green, Red, NIR)\n    height, width = 100, 100\n    data = np.zeros((4, height, width), dtype=np.uint16)\n    \n    # 创建植被斑块图案\n    for i in range(height):\n        for j in range(width):\n            # 模拟不同地物\n            if (i - 50)**2 + (j - 50)**2 < 900:  # 中心植被区\n                data[0, i, j] = 800 + np.random.randint(0, 100)   # Blue\n                data[1, i, j] = 1000 + np.random.randint(0, 100)  # Green\n                data[2, i, j] = 1100 + np.random.randint(0, 100)  # Red\n                data[3, i, j] = 4500 + np.random.randint(0, 500)  # NIR\n            else:  # 裸土区\n                data[0, i, j] = 1500 + np.random.randint(0, 100)\n                data[1, i, j] = 1600 + np.random.randint(0, 100)\n                data[2, i, j] = 1700 + np.random.randint(0, 100)\n                data[3, i, j] = 2000 + np.random.randint(0, 200)\n    \n    # 创建RasterImage对象\n    band_names = {"blue": 0, "green": 1, "red": 2, "nir": 3}\n    metadata = GeoMetadata(crs="EPSG:32649", resolution=10.0)\n    \n    img = RasterImage(data, band_names, metadata)\n    \n    print(f"\\n【影像信息】")\n    print(f"  形状: {img.shape} (波段, 高度, 宽度)")\n    print(f"  波段数: {img.n_bands}")\n    print(f"  坐标系: {img.metadata.crs}")\n    print(f"  分辨率: {img.metadata.resolution}m")\n    \n    # 2.2 获取波段\n    red = img.get_band("red")\n    nir = img.get_band("nir")\n    \n    print(f"\\n【波段统计】")\n    print(f"  Red: min={red.min()}, max={red.max()}, mean={red.mean():.0f}")\n    print(f"  NIR: min={nir.min()}, max={nir.max()}, mean={nir.mean():.0f}")\n    \n    # 2.3 计算NDVI\n    ndvi = compute_ndvi(red, nir)\n    \n    print(f"\\n【NDVI统计】")\n    print(f"  最小值: {ndvi.min():.3f}")\n    print(f"  最大值: {ndvi.max():.3f}")\n    print(f"  平均值: {ndvi.mean():.3f}")\n    print(f"  高植被区(NDVI>0.5)像素数: {(ndvi > 0.5).sum()}")\n    \n    # 2.4 影像裁剪\n    subset = img.subset(slice(40, 60), slice(40, 60))\n    print(f"\\n【影像裁剪】")\n    print(f"  原始形状: {img.shape}")\n    print(f"  裁剪后形状: {subset.shape}")\n    \n    # 2.5 云掩膜\n    print(f"\\n【云掩膜】")\n    cloud_mask = CloudMask(threshold=0.3)\n    \n    # 模拟QA波段\n    qa_band = np.random.randint(0, 100, (height, width))\n    valid_mask = cloud_mask.from_qa_band(qa_band)\n    \n    print(f"  有效像素比例: {valid_mask.sum() / valid_mask.size * 100:.1f}%")\n\n\ndef example_phenology_classification():\n    """\n    示例3: 物候分类\n    ===============\n    \n    基于NDVI时序数据进行作物分类和物候提取。\n    """\n    print("\\n" + "=" * 60)\n    print("示例3: 物候分类")\n    print("=" * 60)\n    \n    # 3.1 创建模拟NDVI时序\n    np.random.seed(42)\n    \n    n_times = 12  # 12期(约每月一期)\n    height, width = 50, 50\n    \n    # 时间轴(月份)\n    months = list(range(1, 13))\n    print(f"\\n【模拟NDVI时序数据】")\n    print(f"  时间序列: {n_times}期 (月度)")\n    print(f"  影像尺寸: {height}×{width}像素")\n    \n    # 创建不同作物的时序特征\n    ndvi_series = np.zeros((n_times, height, width))\n    \n    for i in range(height):\n        for j in range(width):\n            # 分区模拟不同作物\n            if i < height // 3:\n                # 冬小麦: 春季峰值(4月)\n                peak_month = 4\n                base = 0.3\n            elif i < 2 * height // 3:\n                # 夏玉米: 夏季峰值(8月)\n                peak_month = 8\n                base = 0.25\n            else:\n                # 棉花: 晚夏峰值(9月)\n                peak_month = 9\n                base = 0.2\n            \n            # 生成季节性曲线\n            for t in range(n_times):\n                month = t + 1\n                # 高斯型生长曲线\n                ndvi = base + 0.5 * np.exp(-((month - peak_month) ** 2) / 8)\n                ndvi += np.random.randn() * 0.03\n                ndvi_series[t, i, j] = np.clip(ndvi, 0, 1)\n    \n    # 3.2 时序平滑\n    print(f"\\n【时序平滑】")\n    smoothed = temporal_smoothing(ndvi_series, window=3)\n    print(f"  原始噪声标准差: {ndvi_series.std():.3f}")\n    print(f"  平滑后标准差: {smoothed.std():.3f}")\n    \n    # 3.3 物候分类\n    classifier = PhenologyClassifier(ndvi_series)\n    \n    print(f"\\n【物候特征提取】")\n    \n    # 获取不同位置的物候特征\n    positions = [(10, 25), (25, 25), (40, 25)]\n    crop_names = ["冬小麦", "夏玉米", "棉花"]\n    \n    for (row, col), crop_name in zip(positions, crop_names):\n        features = classifier.extract_features(row, col)\n        print(f"\\n  {crop_name} (像素{row},{col}):")\n        print(f"    峰值NDVI: {features.peak_value:.3f}")\n        print(f"    峰值时间: 第{features.peak_time + 1}期 (~{features.peak_time + 1}月)")\n        print(f"    生长季: 第{features.start_of_season + 1}期 ~ 第{features.end_of_season}期")\n        print(f"    振幅: {features.amplitude:.3f}")\n    \n    # 3.4 作物分类\n    print(f"\\n【作物分类】")\n    crop_map = classifier.classify_crops(n_classes=3)\n    \n    print(f"  分类结果统计:")\n    for cls in range(4):\n        count = (crop_map == cls).sum()\n        pct = count / crop_map.size * 100\n        if count > 0:\n            label = ["非作物", "早峰作物", "晚峰作物", "中峰作物"][cls]\n            print(f"    类别{cls} ({label}): {count}像素 ({pct:.1f}%)")\n    \n    # 3.5 物候参数图\n    print(f"\\n【物候参数图】")\n    pheno_maps = classifier.get_phenology_map()\n    \n    for name, data in pheno_maps.items():\n        print(f"  {name}: min={data.min():.2f}, max={data.max():.2f}, mean={data.mean():.2f}")\n\n\ndef example_application():\n    """\n    示例4: 实际应用场景\n    ===================\n    \n    综合应用：农田长势监测。\n    """\n    print("\\n" + "=" * 60)\n    print("示例4: 农田长势监测应用")\n    print("=" * 60)\n    \n    # 4.1 模拟采集的卫星数据\n    np.random.seed(123)\n    \n    # 模拟100×100像素农田\n    h, w = 100, 100\n    \n    # 生成带有空间变异的NDVI\n    x = np.linspace(0, 4*np.pi, w)\n    y = np.linspace(0, 4*np.pi, h)\n    xx, yy = np.meshgrid(x, y)\n    \n    base_ndvi = 0.5 + 0.2 * np.sin(xx) + 0.2 * np.sin(yy)\n    noise = np.random.randn(h, w) * 0.05\n    ndvi = np.clip(base_ndvi + noise, 0, 1)\n    \n    print(f"\\n【农田NDVI分析】")\n    print(f"  农田面积: {h*w}像素 (假设10m分辨率 = 100公顷)")\n    print(f"  NDVI范围: {ndvi.min():.3f} ~ {ndvi.max():.3f}")\n    print(f"  平均NDVI: {ndvi.mean():.3f}")\n    \n    # 4.2 长势分级\n    print(f"\\n【长势分级统计】")\n    grades = {\n        "优良 (NDVI>0.7)": (ndvi > 0.7).sum(),\n        "良好 (0.5-0.7)": ((ndvi >= 0.5) & (ndvi <= 0.7)).sum(),\n        "一般 (0.3-0.5)": ((ndvi >= 0.3) & (ndvi < 0.5)).sum(),\n        "较差 (<0.3)": (ndvi < 0.3).sum(),\n    }\n    \n    for grade, count in grades.items():\n        pct = count / ndvi.size * 100\n        print(f"  {grade}: {count}像素 ({pct:.1f}%)")\n    \n    # 4.3 异常区域识别\n    print(f"\\n【异常区域识别】")\n    threshold = ndvi.mean() - ndvi.std()\n    abnormal_pixels = ndvi < threshold\n    abnormal_count = abnormal_pixels.sum()\n    \n    print(f"  低于阈值({threshold:.3f})的像素: {abnormal_count} ({abnormal_count/ndvi.size*100:.1f}%)")\n    \n    # 4.4 分区统计\n    print(f"\\n【分区统计】")\n    n_zones = 4\n    zone_size = h // 2\n    \n    for zi in range(2):\n        for zj in range(2):\n            zone_ndvi = ndvi[zi*zone_size:(zi+1)*zone_size, \n                            zj*zone_size:(zj+1)*zone_size]\n            zone_name = f"Zone-{zi*2+zj+1}"\n            print(f"  {zone_name}: 平均NDVI={zone_ndvi.mean():.3f}, "\n                  f"标准差={zone_ndvi.std():.3f}")\n\n\nif __name__ == "__main__":\n    print("=" * 60)\n    print("  hetao_ag.space 模块使用示例")\n    print("=" * 60)\n    \n    example_spectral_indices()\n    example_raster_image()\n    example_phenology_classification()\n    example_application()\n    \n    print("\\n" + "=" * 60)\n    print("Space模块示例完成")\n    print("=" * 60)\n',
    "examples/example_water.py": '# -*- coding: utf-8 -*-\n"""\nWater模块使用示例\n=================\n\n演示hetao_ag.water模块的蒸散发计算、水量平衡和灌溉调度功能。\n\n作者: Hetao College\n"""\n\nimport numpy as np\nfrom datetime import date, timedelta\nfrom hetao_ag.water import (\n    # 蒸散发\n    eto_penman_monteith, eto_hargreaves, WeatherData,\n    extraterrestrial_radiation, crop_coefficient, etc_crop,\n    # 水量平衡\n    WaterBalance, WaterBalanceRecord,\n    # 灌溉\n    IrrigationScheduler, IrrigationEvent, IrrigationRecommendation,\n    IrrigationMethod, ScheduleType,\n    calculate_net_irrigation_requirement, gross_irrigation_requirement\n)\n\n\ndef example_evapotranspiration():\n    """\n    示例1: 蒸散发计算\n    =================\n    \n    使用FAO-56 Penman-Monteith方法计算参考作物蒸散发(ET0)。\n    这是灌溉需水量计算的国际标准方法。\n    """\n    print("\\n" + "=" * 60)\n    print("示例1: 蒸散发计算 (FAO-56)")\n    print("=" * 60)\n    \n    # 1.1 准备气象数据\n    # 河套灌区夏季典型气象条件\n    weather = WeatherData(\n        t_mean=26.0,      # 日平均气温 (°C)\n        t_max=33.0,       # 日最高气温 (°C)\n        t_min=19.0,       # 日最低气温 (°C)\n        rh=50.0,          # 相对湿度 (%)\n        u2=2.5,           # 2m高度风速 (m/s)\n        rs=24.0,          # 太阳辐射 (MJ/m²/day)\n        elevation=1050,   # 海拔 (m)\n        latitude=40.8,    # 纬度 (度)\n        doy=195           # 年积日 (7月14日)\n    )\n    \n    print(f"\\n【气象数据】")\n    print(f"  位置: 北纬{weather.latitude}°, 海拔{weather.elevation}m")\n    print(f"  日期: 第{weather.doy}天 (约7月中旬)")\n    print(f"  温度: {weather.t_min}°C ~ {weather.t_max}°C (平均{weather.t_mean}°C)")\n    print(f"  相对湿度: {weather.rh}%")\n    print(f"  风速: {weather.u2} m/s")\n    print(f"  太阳辐射: {weather.rs} MJ/m²/day")\n    \n    # 1.2 FAO-56 Penman-Monteith计算\n    et0_pm = eto_penman_monteith(weather)\n    print(f"\\n【Penman-Monteith ET₀】")\n    print(f"  ET₀ = {et0_pm:.2f} mm/day")\n    \n    # 1.3 天文辐射\n    Ra = extraterrestrial_radiation(weather.latitude, weather.doy)\n    print(f"\\n【天文辐射】")\n    print(f"  Ra = {Ra:.2f} MJ/m²/day")\n    \n    # 1.4 Hargreaves简化方法(仅需温度)\n    et0_hg = eto_hargreaves(weather.t_mean, weather.t_max, weather.t_min, Ra)\n    print(f"\\n【Hargreaves ET₀ (简化方法)】")\n    print(f"  ET₀ = {et0_hg:.2f} mm/day")\n    print(f"  与PM方法差异: {abs(et0_pm - et0_hg):.2f} mm/day ({abs(et0_pm-et0_hg)/et0_pm*100:.1f}%)")\n    \n    # 1.5 作物系数\n    print(f"\\n【作物系数 Kc】")\n    crops = ["wheat", "maize", "cotton", "alfalfa"]\n    stages = ["initial", "mid", "late"]\n    \n    print(f"{\'作物\':>8} {\'初期\':>6} {\'中期\':>6} {\'末期\':>6}")\n    print("-" * 30)\n    for crop in crops:\n        kc_vals = [crop_coefficient(stage, crop) for stage in stages]\n        print(f"{crop:>8} {kc_vals[0]:>6.2f} {kc_vals[1]:>6.2f} {kc_vals[2]:>6.2f}")\n    \n    # 1.6 作物蒸散发ETc\n    kc_wheat_mid = crop_coefficient("mid", "wheat")\n    etc_wheat = etc_crop(et0_pm, kc_wheat_mid)\n    \n    print(f"\\n【小麦中期蒸散发】")\n    print(f"  ET₀ = {et0_pm:.2f} mm/day")\n    print(f"  Kc = {kc_wheat_mid}")\n    print(f"  ETc = ET₀ × Kc = {etc_wheat:.2f} mm/day")\n    \n    # 1.7 水分胁迫调整\n    ks = 0.85  # 假设轻度水分胁迫\n    etc_actual = etc_crop(et0_pm, kc_wheat_mid, ks)\n    print(f"\\n【考虑水分胁迫】")\n    print(f"  Ks = {ks}")\n    print(f"  ETc_adj = ET₀ × Kc × Ks = {etc_actual:.2f} mm/day")\n\n\ndef example_water_balance():\n    """\n    示例2: 水量平衡模型\n    ===================\n    \n    跟踪农田水分收支，用于灌溉决策和水资源管理。\n    """\n    print("\\n" + "=" * 60)\n    print("示例2: 水量平衡模型")\n    print("=" * 60)\n    \n    # 2.1 创建水量平衡模型\n    wb = WaterBalance(\n        initial_storage_mm=90,    # 初始储水量\n        max_storage_mm=120,       # 田间持水量对应储水\n        min_storage_mm=40         # 凋萎点对应储水\n    )\n    \n    print(f"\\n【模型参数】")\n    print(f"  初始储水: {wb.storage_mm} mm")\n    print(f"  最大储水(FC): {wb.max_storage_mm} mm")\n    print(f"  最小储水(WP): {wb.min_storage_mm} mm")\n    print(f"  可用水分范围: {wb.max_storage_mm - wb.min_storage_mm} mm")\n    \n    # 2.2 添加降水\n    infiltration, runoff = wb.add_precipitation(35)\n    print(f"\\n【添加35mm降水】")\n    print(f"  入渗: {infiltration:.1f} mm")\n    print(f"  径流: {runoff:.1f} mm")\n    print(f"  当前储水: {wb.storage_mm:.1f} mm")\n    \n    # 2.3 添加灌溉\n    actual_irrig = wb.add_irrigation(30)\n    print(f"\\n【添加30mm灌溉】")\n    print(f"  实际入渗: {actual_irrig:.1f} mm")\n    print(f"  当前储水: {wb.storage_mm:.1f} mm")\n    \n    # 2.4 蒸散发消耗\n    actual_et = wb.remove_et(8)\n    print(f"\\n【8mm蒸散发】")\n    print(f"  实际ET: {actual_et:.1f} mm")\n    print(f"  当前储水: {wb.storage_mm:.1f} mm")\n    \n    # 2.5 深层渗漏\n    drainage = wb.deep_drainage()\n    print(f"\\n【深层渗漏】")\n    print(f"  渗漏量: {drainage:.1f} mm")\n    \n    # 2.6 20天逐日模拟\n    print(f"\\n【20天逐日模拟】")\n    \n    wb2 = WaterBalance(initial_storage_mm=100, max_storage_mm=120, min_storage_mm=40)\n    \n    # 模拟天气和灌溉\n    np.random.seed(42)\n    \n    print(f"{\'日\':>3} {\'降水\':>6} {\'灌溉\':>6} {\'ET\':>6} {\'储水\':>8} {\'状态\':>8}")\n    print("-" * 45)\n    \n    for day in range(1, 21):\n        # 随机降水\n        rain = 20 if np.random.random() < 0.15 else 0\n        # ET随时间增加\n        et = 4 + day * 0.1 + np.random.random()\n        # 灌溉决策\n        irrig = 40 if wb2.relative_storage < 0.4 else 0\n        \n        record = wb2.step_day(precip_mm=rain, irrig_mm=irrig, et_mm=et)\n        \n        status = "正常" if wb2.relative_storage > 0.5 else ("注意" if wb2.relative_storage > 0.3 else "缺水")\n        \n        if day % 5 == 0 or day == 1:\n            print(f"{day:>3} {rain:>6.0f} {irrig:>6.0f} {record.et_mm:>6.1f} "\n                  f"{record.soil_moisture:>8.1f} {status:>8}")\n    \n    # 2.7 水量平衡汇总\n    summary = wb2.get_summary()\n    print(f"\\n【水量平衡汇总】")\n    for key, value in summary.items():\n        print(f"  {key}: {value:.1f} mm")\n    \n    # 2.8 水分利用效率\n    yield_kg = 5500  # 假设产量5500 kg/ha\n    wue = wb2.water_use_efficiency(yield_kg)\n    print(f"\\n【水分利用效率】")\n    print(f"  产量: {yield_kg} kg/ha")\n    print(f"  WUE: {wue:.2f} kg/m³")\n\n\ndef example_irrigation_scheduling():\n    """\n    示例3: 灌溉调度\n    ===============\n    \n    智能灌溉决策，支持多种调度策略。\n    """\n    print("\\n" + "=" * 60)\n    print("示例3: 灌溉调度")\n    print("=" * 60)\n    \n    # 3.1 创建调度器\n    scheduler = IrrigationScheduler(\n        method=ScheduleType.SOIL_MOISTURE,\n        trigger_threshold=0.5,      # 可用水消耗50%时触发\n        max_application_mm=50,      # 单次最大灌溉量\n        irrigation_efficiency=0.85  # 灌溉效率85%\n    )\n    \n    print(f"\\n【调度器配置】")\n    print(f"  调度方法: {scheduler.method.value}")\n    print(f"  触发阈值: {scheduler.trigger_threshold} (可用水消耗比例)")\n    print(f"  最大灌溉量: {scheduler.max_application_mm} mm")\n    print(f"  灌溉效率: {scheduler.efficiency}")\n    \n    # 3.2 基于土壤水分的灌溉建议\n    print(f"\\n【土壤水分灌溉建议】")\n    \n    # 场景1: 水分充足\n    rec1 = scheduler.recommend_by_moisture(\n        current_moisture=0.28,\n        field_capacity=0.32,\n        wilting_point=0.12,\n        root_depth_m=0.30\n    )\n    print(f"\\n  场景1: 含水量=0.28")\n    print(f"    需灌溉: {\'是\' if rec1.should_irrigate else \'否\'}")\n    print(f"    原因: {rec1.reason}")\n    \n    # 场景2: 水分不足\n    rec2 = scheduler.recommend_by_moisture(\n        current_moisture=0.18,\n        field_capacity=0.32,\n        wilting_point=0.12,\n        root_depth_m=0.30\n    )\n    print(f"\\n  场景2: 含水量=0.18")\n    print(f"    需灌溉: {\'是\' if rec2.should_irrigate else \'否\'}")\n    print(f"    建议量: {rec2.amount_mm:.1f} mm")\n    print(f"    紧急程度: {rec2.urgency}")\n    print(f"    原因: {rec2.reason}")\n    \n    # 场景3: 严重缺水\n    rec3 = scheduler.recommend_by_moisture(\n        current_moisture=0.14,\n        field_capacity=0.32,\n        wilting_point=0.12,\n        root_depth_m=0.30\n    )\n    print(f"\\n  场景3: 含水量=0.14 (接近凋萎点)")\n    print(f"    需灌溉: {\'是\' if rec3.should_irrigate else \'否\'}")\n    print(f"    建议量: {rec3.amount_mm:.1f} mm")\n    print(f"    紧急程度: {rec3.urgency}")\n    \n    # 3.3 基于ET的灌溉建议\n    scheduler_et = IrrigationScheduler(method=ScheduleType.ET_BASED)\n    \n    rec_et = scheduler_et.recommend_by_et(\n        days_since_irrigation=5,\n        cumulative_et_mm=32,\n        cumulative_rain_mm=10\n    )\n    \n    print(f"\\n【基于ET的灌溉建议】")\n    print(f"  距上次灌溉: 5天")\n    print(f"  累计ET: 32 mm")\n    print(f"  累计降水: 10 mm")\n    print(f"  净亏缺: 22 mm")\n    print(f"  需灌溉: {\'是\' if rec_et.should_irrigate else \'否\'}")\n    if rec_et.should_irrigate:\n        print(f"  建议量: {rec_et.amount_mm:.1f} mm")\n    \n    # 3.4 固定间隔灌溉计划\n    print(f"\\n【固定间隔灌溉计划】")\n    events = scheduler.fixed_schedule(\n        interval_days=7,\n        amount_mm=40,\n        total_days=60,\n        start_day=0\n    )\n    \n    print(f"  灌溉间隔: 7天")\n    print(f"  每次灌溉: 40mm")\n    print(f"  计划周期: 60天")\n    print(f"  灌溉次数: {len(events)}")\n    print(f"  总灌溉量: {scheduler.total_irrigation():.0f} mm")\n    \n    # 3.5 亏缺灌溉\n    print(f"\\n【亏缺灌溉计划】")\n    daily_et = np.array([5.0 + 0.1*i for i in range(60)])  # 逐日ET\n    \n    deficit_events = scheduler.deficit_irrigation_schedule(\n        full_et_mm=daily_et,\n        deficit_fraction=0.75,  # 仅补充75%的ET\n        min_interval=4\n    )\n    \n    print(f"  亏缺系数: 0.75 (节水25%)")\n    print(f"  灌溉次数: {len(deficit_events)}")\n    print(f"  总灌溉量: {sum(e.amount_mm for e in deficit_events):.0f} mm")\n    \n    # 3.6 计算灌溉需水量\n    print(f"\\n【灌溉需水量计算】")\n    et_mm = 45\n    effective_rain = 15\n    \n    nir = calculate_net_irrigation_requirement(et_mm, effective_rain)\n    gir = gross_irrigation_requirement(nir, efficiency=0.85)\n    \n    print(f"  作物需水(ETc): {et_mm} mm")\n    print(f"  有效降水: {effective_rain} mm")\n    print(f"  净灌溉需求: {nir:.1f} mm")\n    print(f"  毛灌溉需求(效率85%): {gir:.1f} mm")\n\n\nif __name__ == "__main__":\n    print("=" * 60)\n    print("  hetao_ag.water 模块使用示例")\n    print("=" * 60)\n    \n    example_evapotranspiration()\n    example_water_balance()\n    example_irrigation_scheduling()\n    \n    print("\\n" + "=" * 60)\n    print("Water模块示例完成")\n    print("=" * 60)\n',

}

def setup_package():
    """Write all files to disk"""
    print("=[ Setting up Package ]" + "="*45)
    base_path = Path.cwd()
    
    for rel_path, content in FILES.items():
        full_path = base_path / rel_path
        write_file(full_path, content)
        
    # Ensure current directory is in python path
    if str(base_path) not in sys.path:
        sys.path.insert(0, str(base_path))
    print("Package installed locally.\n")

def run_tests():
    """Run the test suite"""
    print("=[ Running Tests ]" + "="*50)
    import pytest
    try:
        # Run our specific test script as a module or calling its main
        # But since we have tests/test_all.py, let's run that using subprocess for isolation
        # or import it. subprocess is safer for environment variables.
        pass
    except ImportError:
        pass
        
    # Using the existing test script
    test_script = Path("tests/test_all.py")
    if test_script.exists():
        print(f"Executing {test_script}...")
        result = subprocess.call([sys.executable, str(test_script)])
        if result == 0:
            print(">> ALL TESTS PASSED <<")
        else:
            print(">> TESTS FAILED <<")
    else:
        print("Test script not found!")
    print("")

def run_examples():
    """Run usage examples"""
    print("=[ Running Examples ]" + "="*47)
    
    examples = [
        "examples/example_core.py",
        "examples/example_soil.py",
        "examples/example_water.py",
        "examples/example_crop.py",
        "examples/example_livestock.py",
        "examples/example_space.py",
        "examples/example_opt.py",
        "examples/demo.py"
    ]
    
    for ex in examples:
        p = Path(ex)
        if p.exists():
            print(f"\nRunning {ex}...")
            print("-" * 60)
            subprocess.call([sys.executable, str(p)])
            print("-" * 60)

if __name__ == "__main__":
    install_dependencies()
    setup_package()
    
    # Re-import to ensure modules are found
    import importlib
    importlib.invalidate_caches()
    
    run_tests()
    run_examples()
    
    print("\n=[ COMPLETE ]" + "="*55)
    print("The hetao_ag library is now ready to use in this Colab session.")
    print("Try importing modules:")
    print("  from hetao_ag.core import ...")
    print("  from hetao_ag.soil import ...")
